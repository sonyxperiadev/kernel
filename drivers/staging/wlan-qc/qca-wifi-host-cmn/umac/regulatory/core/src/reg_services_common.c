/*
 * Copyright (c) 2014-2020 The Linux Foundation. All rights reserved.
 *
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * DOC: reg_services_common.c
 * This file defines regulatory component service functions
 */

#include <wlan_cmn.h>
#include <reg_services_public_struct.h>
#include <wlan_objmgr_psoc_obj.h>
#include <qdf_lock.h>
#include "reg_priv_objs.h"
#include "reg_utils.h"
#include "reg_callbacks.h"
#include "reg_services_common.h"
#include <wlan_objmgr_psoc_obj.h>
#include "reg_db.h"
#include "reg_db_parser.h"
#include "reg_build_chan_list.h"
#include <wlan_objmgr_pdev_obj.h>
#include <target_if.h>

const struct chan_map *channel_map;
#ifdef CONFIG_CHAN_NUM_API
static const struct bonded_channel bonded_chan_40mhz_list[] = {
	{36, 40},
	{44, 48},
	{52, 56},
	{60, 64},
	{100, 104},
	{108, 112},
	{116, 120},
	{124, 128},
	{132, 136},
	{140, 144},
	{149, 153},
	{157, 161},
	{165, 169},
	{173, 177}
};

static const struct bonded_channel bonded_chan_80mhz_list[] = {
	{36, 48},
	{52, 64},
	{100, 112},
	{116, 128},
	{132, 144},
	{149, 161},
	{165, 177}
};

static const struct bonded_channel bonded_chan_160mhz_list[] = {
	{36, 64},
	{100, 128},
	{149, 177}
};
#endif /* CONFIG_CHAN_NUM_API */

#ifdef CONFIG_CHAN_FREQ_API
/* bonded_chan_40mhz_list_freq - List of 40MHz bonnded channel frequencies */
static const struct bonded_channel_freq bonded_chan_40mhz_list_freq[] = {
	{5180, 5200},
	{5220, 5240},
	{5260, 5280},
	{5300, 5320},
	{5500, 5520},
	{5540, 5560},
	{5580, 5600},
	{5620, 5640},
	{5660, 5680},
	{5700, 5720},
	{5745, 5765},
	{5785, 5805},
	{5825, 5845},
	{5865, 5885},
#ifdef CONFIG_BAND_6GHZ
	{5955, 5975},
	{5995, 6015},
	{6035, 6055},
	{6075, 6095},
	{6115, 6135},
	{6155, 6175},
	{6195, 6215},
	{6235, 6255},
	{6275, 6295},
	{6315, 6335},
	{6355, 6375},
	{6395, 6415},
	{6435, 6455},
	{6475, 6495},
	{6515, 6535},
	{6555, 6575},
	{6595, 6615},
	{6635, 6655},
	{6675, 6695},
	{6715, 6735},
	{6755, 6775},
	{6795, 6815},
	{6835, 6855},
	{6875, 6895},
	{6915, 6935},
	{6955, 6975},
	{6995, 7015},
	{7035, 7055},
	{7075, 7095}
#endif /*CONFIG_BAND_6GHZ*/
};

/* bonded_chan_80mhz_list_freq - List of 80MHz bonnded channel frequencies */
static const struct bonded_channel_freq bonded_chan_80mhz_list_freq[] = {
	{5180, 5240},
	{5260, 5320},
	{5500, 5560},
	{5580, 5640},
	{5660, 5720},
	{5745, 5805},
	{5825, 5885},
#ifdef CONFIG_BAND_6GHZ
	{5955, 6015},
	{6035, 6095},
	{6115, 6175},
	{6195, 6255},
	{6275, 6335},
	{6355, 6415},
	{6435, 6495},
	{6515, 6575},
	{6595, 6655},
	{6675, 6735},
	{6755, 6815},
	{6835, 6895},
	{6915, 6975},
	{6995, 7055}
#endif /*CONFIG_BAND_6GHZ*/
};

/* bonded_chan_160mhz_list_freq - List of 160MHz bonnded channel frequencies */
static const struct bonded_channel_freq bonded_chan_160mhz_list_freq[] = {
	{5180, 5320},
	{5500, 5640},
	{5745, 5885},
#ifdef CONFIG_BAND_6GHZ
	{5955, 6095},
	{6115, 6255},
	{6275, 6415},
	{6435, 6575},
	{6595, 6735},
	{6755, 6895},
	{6915, 7055}
#endif /*CONFIG_BAND_6GHZ*/
};
#endif /*CONFIG_CHAN_FREQ_API*/

static const enum phy_ch_width get_next_lower_bw[] = {
	[CH_WIDTH_80P80MHZ] = CH_WIDTH_160MHZ,
	[CH_WIDTH_160MHZ] = CH_WIDTH_80MHZ,
	[CH_WIDTH_80MHZ] = CH_WIDTH_40MHZ,
	[CH_WIDTH_40MHZ] = CH_WIDTH_20MHZ,
	[CH_WIDTH_20MHZ] = CH_WIDTH_10MHZ,
	[CH_WIDTH_10MHZ] = CH_WIDTH_5MHZ,
	[CH_WIDTH_5MHZ] = CH_WIDTH_INVALID
};

const struct chan_map channel_map_us[NUM_CHANNELS] = {
	[CHAN_ENUM_2412] = {2412, 1, 20, 40},
	[CHAN_ENUM_2417] = {2417, 2, 20, 40},
	[CHAN_ENUM_2422] = {2422, 3, 20, 40},
	[CHAN_ENUM_2427] = {2427, 4, 20, 40},
	[CHAN_ENUM_2432] = {2432, 5, 20, 40},
	[CHAN_ENUM_2437] = {2437, 6, 20, 40},
	[CHAN_ENUM_2442] = {2442, 7, 20, 40},
	[CHAN_ENUM_2447] = {2447, 8, 20, 40},
	[CHAN_ENUM_2452] = {2452, 9, 20, 40},
	[CHAN_ENUM_2457] = {2457, 10, 20, 40},
	[CHAN_ENUM_2462] = {2462, 11, 20, 40},
	[CHAN_ENUM_2467] = {2467, 12, 20, 40},
	[CHAN_ENUM_2472] = {2472, 13, 20, 40},
	[CHAN_ENUM_2484] = {2484, 14, 20, 20},

	[CHAN_ENUM_4912] = {4912, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4915] = {4915, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4917] = {4917, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4920] = {4920, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4922] = {4922, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4925] = {4925, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4927] = {4927, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4932] = {4932, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4935] = {4935, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4937] = {4937, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4940] = {4940, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4942] = {4942, 1, 5, 5},
	[CHAN_ENUM_4945] = {4945, 11, 10, 10},
	[CHAN_ENUM_4947] = {4947, 2, 5, 5},
	[CHAN_ENUM_4950] = {4950, 20, 10, 20},
	[CHAN_ENUM_4952] = {4952, 3, 5, 5},
	[CHAN_ENUM_4955] = {4955, 21, 10, 20},
	[CHAN_ENUM_4957] = {4957, 4, 5, 5},
	[CHAN_ENUM_4960] = {4960, 22, 10, 20},
	[CHAN_ENUM_4962] = {4962, 5, 5, 5},
	[CHAN_ENUM_4965] = {4965, 23, 10, 20},
	[CHAN_ENUM_4967] = {4967, 6, 5, 5},
	[CHAN_ENUM_4970] = {4970, 24, 10, 20},
	[CHAN_ENUM_4972] = {4972, 7, 5, 5},
	[CHAN_ENUM_4975] = {4975, 25, 10, 20},
	[CHAN_ENUM_4977] = {4977, 8, 5, 5},
	[CHAN_ENUM_4980] = {4980, 26, 10, 20},
	[CHAN_ENUM_4982] = {4982, 9, 5, 5},
	[CHAN_ENUM_4985] = {4985, 19, 10, 10},
	[CHAN_ENUM_4987] = {4987, 10, 5, 5},
	[CHAN_ENUM_5032] = {5032, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5035] = {5035, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5037] = {5037, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5040] = {5040, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5042] = {5042, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5045] = {5045, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5047] = {5047, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5052] = {5052, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5055] = {5055, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5057] = {5057, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5060] = {5060, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5080] = {5080, INVALID_CHANNEL_NUM, 2, 20},

	[CHAN_ENUM_5180] = {5180, 36, 2, 160},
	[CHAN_ENUM_5200] = {5200, 40, 2, 160},
	[CHAN_ENUM_5220] = {5220, 44, 2, 160},
	[CHAN_ENUM_5240] = {5240, 48, 2, 160},
	[CHAN_ENUM_5260] = {5260, 52, 2, 160},
	[CHAN_ENUM_5280] = {5280, 56, 2, 160},
	[CHAN_ENUM_5300] = {5300, 60, 2, 160},
	[CHAN_ENUM_5320] = {5320, 64, 2, 160},
	[CHAN_ENUM_5500] = {5500, 100, 2, 160},
	[CHAN_ENUM_5520] = {5520, 104, 2, 160},
	[CHAN_ENUM_5540] = {5540, 108, 2, 160},
	[CHAN_ENUM_5560] = {5560, 112, 2, 160},
	[CHAN_ENUM_5580] = {5580, 116, 2, 160},
	[CHAN_ENUM_5600] = {5600, 120, 2, 160},
	[CHAN_ENUM_5620] = {5620, 124, 2, 160},
	[CHAN_ENUM_5640] = {5640, 128, 2, 160},
	[CHAN_ENUM_5660] = {5660, 132, 2, 160},
	[CHAN_ENUM_5680] = {5680, 136, 2, 160},
	[CHAN_ENUM_5700] = {5700, 140, 2, 160},
	[CHAN_ENUM_5720] = {5720, 144, 2, 160},
	[CHAN_ENUM_5745] = {5745, 149, 2, 160},
	[CHAN_ENUM_5765] = {5765, 153, 2, 160},
	[CHAN_ENUM_5785] = {5785, 157, 2, 160},
	[CHAN_ENUM_5805] = {5805, 161, 2, 160},
	[CHAN_ENUM_5825] = {5825, 165, 2, 160},
	[CHAN_ENUM_5845] = {5845, 169, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5850] = {5850, 170, 2, 160},
	[CHAN_ENUM_5855] = {5855, 171, 2, 160},
	[CHAN_ENUM_5860] = {5860, 172, 2, 160},
#endif
	[CHAN_ENUM_5865] = {5865, 173, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5870] = {5870, 174, 2, 160},
	[CHAN_ENUM_5875] = {5875, 175, 2, 160},
	[CHAN_ENUM_5880] = {5880, 176, 2, 160},
#endif
	[CHAN_ENUM_5885] = {5885, 177, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5890] = {5890, 178, 2, 160},
	[CHAN_ENUM_5895] = {5895, 179, 2, 160},
	[CHAN_ENUM_5900] = {5900, 180, 2, 160},
	[CHAN_ENUM_5905] = {5905, 181, 2, 160},
	[CHAN_ENUM_5910] = {5910, 182, 2, 160},
	[CHAN_ENUM_5915] = {5915, 183, 2, 160},
	[CHAN_ENUM_5920] = {5920, 184, 2, 160},
#endif /* WLAN_FEATURE_DSRC */
#ifdef CONFIG_BAND_6GHZ
	[CHAN_ENUM_5935] = {5935, 2, 2, 20},
	[CHAN_ENUM_5955] = {5955, 1, 2, 160},
	[CHAN_ENUM_5975] = {5975, 5, 2, 160},
	[CHAN_ENUM_5995] = {5995, 9, 2, 160},
	[CHAN_ENUM_6015] = {6015, 13, 2, 160},
	[CHAN_ENUM_6035] = {6035, 17, 2, 160},
	[CHAN_ENUM_6055] = {6055, 21, 2, 160},
	[CHAN_ENUM_6075] = {6075, 25, 2, 160},
	[CHAN_ENUM_6095] = {6095, 29, 2, 160},
	[CHAN_ENUM_6115] = {6115, 33, 2, 160},
	[CHAN_ENUM_6135] = {6135, 37, 2, 160},
	[CHAN_ENUM_6155] = {6155, 41, 2, 160},
	[CHAN_ENUM_6175] = {6175, 45, 2, 160},
	[CHAN_ENUM_6195] = {6195, 49, 2, 160},
	[CHAN_ENUM_6215] = {6215, 53, 2, 160},
	[CHAN_ENUM_6235] = {6235, 57, 2, 160},
	[CHAN_ENUM_6255] = {6255, 61, 2, 160},
	[CHAN_ENUM_6275] = {6275, 65, 2, 160},
	[CHAN_ENUM_6295] = {6295, 69, 2, 160},
	[CHAN_ENUM_6315] = {6315, 73, 2, 160},
	[CHAN_ENUM_6335] = {6335, 77, 2, 160},
	[CHAN_ENUM_6355] = {6355, 81, 2, 160},
	[CHAN_ENUM_6375] = {6375, 85, 2, 160},
	[CHAN_ENUM_6395] = {6395, 89, 2, 160},
	[CHAN_ENUM_6415] = {6415, 93, 2, 160},
	[CHAN_ENUM_6435] = {6435, 97, 2, 160},
	[CHAN_ENUM_6455] = {6455, 101, 2, 160},
	[CHAN_ENUM_6475] = {6475, 105, 2, 160},
	[CHAN_ENUM_6495] = {6495, 109, 2, 160},
	[CHAN_ENUM_6515] = {6515, 113, 2, 160},
	[CHAN_ENUM_6535] = {6535, 117, 2, 160},
	[CHAN_ENUM_6555] = {6555, 121, 2, 160},
	[CHAN_ENUM_6575] = {6575, 125, 2, 160},
	[CHAN_ENUM_6595] = {6595, 129, 2, 160},
	[CHAN_ENUM_6615] = {6615, 133, 2, 160},
	[CHAN_ENUM_6635] = {6635, 137, 2, 160},
	[CHAN_ENUM_6655] = {6655, 141, 2, 160},
	[CHAN_ENUM_6675] = {6675, 145, 2, 160},
	[CHAN_ENUM_6695] = {6695, 149, 2, 160},
	[CHAN_ENUM_6715] = {6715, 153, 2, 160},
	[CHAN_ENUM_6735] = {6735, 157, 2, 160},
	[CHAN_ENUM_6755] = {6755, 161, 2, 160},
	[CHAN_ENUM_6775] = {6775, 165, 2, 160},
	[CHAN_ENUM_6795] = {6795, 169, 2, 160},
	[CHAN_ENUM_6815] = {6815, 173, 2, 160},
	[CHAN_ENUM_6835] = {6835, 177, 2, 160},
	[CHAN_ENUM_6855] = {6855, 181, 2, 160},
	[CHAN_ENUM_6875] = {6875, 185, 2, 160},
	[CHAN_ENUM_6895] = {6895, 189, 2, 160},
	[CHAN_ENUM_6915] = {6915, 193, 2, 160},
	[CHAN_ENUM_6935] = {6935, 197, 2, 160},
	[CHAN_ENUM_6955] = {6955, 201, 2, 160},
	[CHAN_ENUM_6975] = {6975, 205, 2, 160},
	[CHAN_ENUM_6995] = {6995, 209, 2, 160},
	[CHAN_ENUM_7015] = {7015, 213, 2, 160},
	[CHAN_ENUM_7035] = {7035, 217, 2, 160},
	[CHAN_ENUM_7055] = {7055, 221, 2, 160},
	[CHAN_ENUM_7075] = {7075, 225, 2, 160},
	[CHAN_ENUM_7095] = {7095, 229, 2, 160},
	[CHAN_ENUM_7115] = {7115, 233, 2, 160}
#endif /* CONFIG_BAND_6GHZ */
};

const struct chan_map channel_map_eu[NUM_CHANNELS] = {
	[CHAN_ENUM_2412] = {2412, 1, 20, 40},
	[CHAN_ENUM_2417] = {2417, 2, 20, 40},
	[CHAN_ENUM_2422] = {2422, 3, 20, 40},
	[CHAN_ENUM_2427] = {2427, 4, 20, 40},
	[CHAN_ENUM_2432] = {2432, 5, 20, 40},
	[CHAN_ENUM_2437] = {2437, 6, 20, 40},
	[CHAN_ENUM_2442] = {2442, 7, 20, 40},
	[CHAN_ENUM_2447] = {2447, 8, 20, 40},
	[CHAN_ENUM_2452] = {2452, 9, 20, 40},
	[CHAN_ENUM_2457] = {2457, 10, 20, 40},
	[CHAN_ENUM_2462] = {2462, 11, 20, 40},
	[CHAN_ENUM_2467] = {2467, 12, 20, 40},
	[CHAN_ENUM_2472] = {2472, 13, 20, 40},
	[CHAN_ENUM_2484] = {2484, 14, 20, 20},

	[CHAN_ENUM_4912] = {4912, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4915] = {4915, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4917] = {4917, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4920] = {4920, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4922] = {4922, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4925] = {4925, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4927] = {4927, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4932] = {4932, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4935] = {4935, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4937] = {4937, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4940] = {4940, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4942] = {4942, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4945] = {4945, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4947] = {4947, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4950] = {4950, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4952] = {4952, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4955] = {4955, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4957] = {4957, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4960] = {4960, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4962] = {4962, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4965] = {4965, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4967] = {4967, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4970] = {4970, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4972] = {4972, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4975] = {4975, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4977] = {4977, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4980] = {4980, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4982] = {4982, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4985] = {4985, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4987] = {4987, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5032] = {5032, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5035] = {5035, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5037] = {5037, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5040] = {5040, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5042] = {5042, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5045] = {5045, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5047] = {5047, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5052] = {5052, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5055] = {5055, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5057] = {5057, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5060] = {5060, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5080] = {5080, INVALID_CHANNEL_NUM, 2, 20},

	[CHAN_ENUM_5180] = {5180, 36, 2, 160},
	[CHAN_ENUM_5200] = {5200, 40, 2, 160},
	[CHAN_ENUM_5220] = {5220, 44, 2, 160},
	[CHAN_ENUM_5240] = {5240, 48, 2, 160},
	[CHAN_ENUM_5260] = {5260, 52, 2, 160},
	[CHAN_ENUM_5280] = {5280, 56, 2, 160},
	[CHAN_ENUM_5300] = {5300, 60, 2, 160},
	[CHAN_ENUM_5320] = {5320, 64, 2, 160},
	[CHAN_ENUM_5500] = {5500, 100, 2, 160},
	[CHAN_ENUM_5520] = {5520, 104, 2, 160},
	[CHAN_ENUM_5540] = {5540, 108, 2, 160},
	[CHAN_ENUM_5560] = {5560, 112, 2, 160},
	[CHAN_ENUM_5580] = {5580, 116, 2, 160},
	[CHAN_ENUM_5600] = {5600, 120, 2, 160},
	[CHAN_ENUM_5620] = {5620, 124, 2, 160},
	[CHAN_ENUM_5640] = {5640, 128, 2, 160},
	[CHAN_ENUM_5660] = {5660, 132, 2, 160},
	[CHAN_ENUM_5680] = {5680, 136, 2, 160},
	[CHAN_ENUM_5700] = {5700, 140, 2, 160},
	[CHAN_ENUM_5720] = {5720, 144, 2, 160},
	[CHAN_ENUM_5745] = {5745, 149, 2, 160},
	[CHAN_ENUM_5765] = {5765, 153, 2, 160},
	[CHAN_ENUM_5785] = {5785, 157, 2, 160},
	[CHAN_ENUM_5805] = {5805, 161, 2, 160},
	[CHAN_ENUM_5825] = {5825, 165, 2, 160},
	[CHAN_ENUM_5845] = {5845, 169, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5850] = {5850, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5855] = {5855, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5860] = {5860, INVALID_CHANNEL_NUM, 2, 160},
#endif
	[CHAN_ENUM_5865] = {5865, 173, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5870] = {5870, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5875] = {5875, 175, 2, 160},
	[CHAN_ENUM_5880] = {5880, 176, 2, 160},
#endif
	[CHAN_ENUM_5885] = {5885, 177, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5890] = {5890, 178, 2, 160},
	[CHAN_ENUM_5895] = {5895, 179, 2, 160},
	[CHAN_ENUM_5900] = {5900, 180, 2, 160},
	[CHAN_ENUM_5905] = {5905, 181, 2, 160},
	[CHAN_ENUM_5910] = {5910, 182, 2, 160},
	[CHAN_ENUM_5915] = {5915, 183, 2, 160},
	[CHAN_ENUM_5920] = {5920, 184, 2, 160},
#endif /* WLAN_FEATURE_DSRC */
#ifdef CONFIG_BAND_6GHZ
	[CHAN_ENUM_5935] = {5935, 2, 2, 20},
	[CHAN_ENUM_5955] = {5955, 1, 2, 160},
	[CHAN_ENUM_5975] = {5975, 5, 2, 160},
	[CHAN_ENUM_5995] = {5995, 9, 2, 160},
	[CHAN_ENUM_6015] = {6015, 13, 2, 160},
	[CHAN_ENUM_6035] = {6035, 17, 2, 160},
	[CHAN_ENUM_6055] = {6055, 21, 2, 160},
	[CHAN_ENUM_6075] = {6075, 25, 2, 160},
	[CHAN_ENUM_6095] = {6095, 29, 2, 160},
	[CHAN_ENUM_6115] = {6115, 33, 2, 160},
	[CHAN_ENUM_6135] = {6135, 37, 2, 160},
	[CHAN_ENUM_6155] = {6155, 41, 2, 160},
	[CHAN_ENUM_6175] = {6175, 45, 2, 160},
	[CHAN_ENUM_6195] = {6195, 49, 2, 160},
	[CHAN_ENUM_6215] = {6215, 53, 2, 160},
	[CHAN_ENUM_6235] = {6235, 57, 2, 160},
	[CHAN_ENUM_6255] = {6255, 61, 2, 160},
	[CHAN_ENUM_6275] = {6275, 65, 2, 160},
	[CHAN_ENUM_6295] = {6295, 69, 2, 160},
	[CHAN_ENUM_6315] = {6315, 73, 2, 160},
	[CHAN_ENUM_6335] = {6335, 77, 2, 160},
	[CHAN_ENUM_6355] = {6355, 81, 2, 160},
	[CHAN_ENUM_6375] = {6375, 85, 2, 160},
	[CHAN_ENUM_6395] = {6395, 89, 2, 160},
	[CHAN_ENUM_6415] = {6415, 93, 2, 160},
	[CHAN_ENUM_6435] = {6435, 97, 2, 160},
	[CHAN_ENUM_6455] = {6455, 101, 2, 160},
	[CHAN_ENUM_6475] = {6475, 105, 2, 160},
	[CHAN_ENUM_6495] = {6495, 109, 2, 160},
	[CHAN_ENUM_6515] = {6515, 113, 2, 160},
	[CHAN_ENUM_6535] = {6535, 117, 2, 160},
	[CHAN_ENUM_6555] = {6555, 121, 2, 160},
	[CHAN_ENUM_6575] = {6575, 125, 2, 160},
	[CHAN_ENUM_6595] = {6595, 129, 2, 160},
	[CHAN_ENUM_6615] = {6615, 133, 2, 160},
	[CHAN_ENUM_6635] = {6635, 137, 2, 160},
	[CHAN_ENUM_6655] = {6655, 141, 2, 160},
	[CHAN_ENUM_6675] = {6675, 145, 2, 160},
	[CHAN_ENUM_6695] = {6695, 149, 2, 160},
	[CHAN_ENUM_6715] = {6715, 153, 2, 160},
	[CHAN_ENUM_6735] = {6735, 157, 2, 160},
	[CHAN_ENUM_6755] = {6755, 161, 2, 160},
	[CHAN_ENUM_6775] = {6775, 165, 2, 160},
	[CHAN_ENUM_6795] = {6795, 169, 2, 160},
	[CHAN_ENUM_6815] = {6815, 173, 2, 160},
	[CHAN_ENUM_6835] = {6835, 177, 2, 160},
	[CHAN_ENUM_6855] = {6855, 181, 2, 160},
	[CHAN_ENUM_6875] = {6875, 185, 2, 160},
	[CHAN_ENUM_6895] = {6895, 189, 2, 160},
	[CHAN_ENUM_6915] = {6915, 193, 2, 160},
	[CHAN_ENUM_6935] = {6935, 197, 2, 160},
	[CHAN_ENUM_6955] = {6955, 201, 2, 160},
	[CHAN_ENUM_6975] = {6975, 205, 2, 160},
	[CHAN_ENUM_6995] = {6995, 209, 2, 160},
	[CHAN_ENUM_7015] = {7015, 213, 2, 160},
	[CHAN_ENUM_7035] = {7035, 217, 2, 160},
	[CHAN_ENUM_7055] = {7055, 221, 2, 160},
	[CHAN_ENUM_7075] = {7075, 225, 2, 160},
	[CHAN_ENUM_7095] = {7095, 229, 2, 160},
	[CHAN_ENUM_7115] = {7115, 233, 2, 160}
#endif /* CONFIG_BAND_6GHZ */
};

const struct chan_map channel_map_jp[NUM_CHANNELS] = {
	[CHAN_ENUM_2412] = {2412, 1, 20, 40},
	[CHAN_ENUM_2417] = {2417, 2, 20, 40},
	[CHAN_ENUM_2422] = {2422, 3, 20, 40},
	[CHAN_ENUM_2427] = {2427, 4, 20, 40},
	[CHAN_ENUM_2432] = {2432, 5, 20, 40},
	[CHAN_ENUM_2437] = {2437, 6, 20, 40},
	[CHAN_ENUM_2442] = {2442, 7, 20, 40},
	[CHAN_ENUM_2447] = {2447, 8, 20, 40},
	[CHAN_ENUM_2452] = {2452, 9, 20, 40},
	[CHAN_ENUM_2457] = {2457, 10, 20, 40},
	[CHAN_ENUM_2462] = {2462, 11, 20, 40},
	[CHAN_ENUM_2467] = {2467, 12, 20, 40},
	[CHAN_ENUM_2472] = {2472, 13, 20, 40},
	[CHAN_ENUM_2484] = {2484, 14, 20, 20},

	[CHAN_ENUM_4912] = {4912, 182, 5, 5},
	[CHAN_ENUM_4915] = {4915, 183, 10, 10},
	[CHAN_ENUM_4917] = {4917, 183, 5, 5},
	[CHAN_ENUM_4920] = {4920, 184, 10, 20},
	[CHAN_ENUM_4922] = {4922, 184, 5, 5},
	[CHAN_ENUM_4925] = {4925, 185, 10, 10},
	[CHAN_ENUM_4927] = {4927, 185, 5, 5},
	[CHAN_ENUM_4932] = {4932, 186, 5, 5},
	[CHAN_ENUM_4935] = {4935, 187, 10, 10},
	[CHAN_ENUM_4937] = {4937, 187, 5, 5},
	[CHAN_ENUM_4940] = {4940, 188, 10, 20},
	[CHAN_ENUM_4942] = {4942, 188, 5, 5},
	[CHAN_ENUM_4945] = {4945, 189, 10, 10},
	[CHAN_ENUM_4947] = {4947, 189, 5, 5},
	[CHAN_ENUM_4950] = {4950, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4952] = {4952, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4955] = {4955, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4957] = {4957, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4960] = {4960, 192, 20, 20},
	[CHAN_ENUM_4962] = {4962, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4965] = {4965, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4967] = {4967, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4970] = {4970, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4972] = {4972, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4975] = {4975, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4977] = {4977, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4980] = {4980, 196, 20, 20},
	[CHAN_ENUM_4982] = {4982, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4985] = {4985, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4987] = {4987, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5032] = {5032, 6, 5, 5},
	[CHAN_ENUM_5035] = {5035, 7, 10, 10},
	[CHAN_ENUM_5037] = {5037, 7, 5, 5},
	[CHAN_ENUM_5040] = {5040, 8, 10, 20},
	[CHAN_ENUM_5042] = {5042, 8, 5, 5},
	[CHAN_ENUM_5045] = {5045, 9, 10, 10},
	[CHAN_ENUM_5047] = {5047, 9, 5, 5},
	[CHAN_ENUM_5052] = {5052, 10, 5, 5},
	[CHAN_ENUM_5055] = {5055, 11, 10, 10},
	[CHAN_ENUM_5057] = {5057, 11, 5, 5},
	[CHAN_ENUM_5060] = {5060, 12, 20, 20},
	[CHAN_ENUM_5080] = {5080, 16, 20, 20},

	[CHAN_ENUM_5180] = {5180, 36, 2, 160},
	[CHAN_ENUM_5200] = {5200, 40, 2, 160},
	[CHAN_ENUM_5220] = {5220, 44, 2, 160},
	[CHAN_ENUM_5240] = {5240, 48, 2, 160},
	[CHAN_ENUM_5260] = {5260, 52, 2, 160},
	[CHAN_ENUM_5280] = {5280, 56, 2, 160},
	[CHAN_ENUM_5300] = {5300, 60, 2, 160},
	[CHAN_ENUM_5320] = {5320, 64, 2, 160},
	[CHAN_ENUM_5500] = {5500, 100, 2, 160},
	[CHAN_ENUM_5520] = {5520, 104, 2, 160},
	[CHAN_ENUM_5540] = {5540, 108, 2, 160},
	[CHAN_ENUM_5560] = {5560, 112, 2, 160},
	[CHAN_ENUM_5580] = {5580, 116, 2, 160},
	[CHAN_ENUM_5600] = {5600, 120, 2, 160},
	[CHAN_ENUM_5620] = {5620, 124, 2, 160},
	[CHAN_ENUM_5640] = {5640, 128, 2, 160},
	[CHAN_ENUM_5660] = {5660, 132, 2, 160},
	[CHAN_ENUM_5680] = {5680, 136, 2, 160},
	[CHAN_ENUM_5700] = {5700, 140, 2, 160},
	[CHAN_ENUM_5720] = {5720, 144, 2, 160},
	[CHAN_ENUM_5745] = {5745, 149, 2, 160},
	[CHAN_ENUM_5765] = {5765, 153, 2, 160},
	[CHAN_ENUM_5785] = {5785, 157, 2, 160},
	[CHAN_ENUM_5805] = {5805, 161, 2, 160},
	[CHAN_ENUM_5825] = {5825, 165, 2, 160},
	[CHAN_ENUM_5845] = {5845, 169, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5850] = {5850, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5855] = {5855, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5860] = {5860, INVALID_CHANNEL_NUM, 2, 160},
#endif
	[CHAN_ENUM_5865] = {5865, INVALID_CHANNEL_NUM, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5870] = {5870, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5875] = {5875, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5880] = {5880, INVALID_CHANNEL_NUM, 2, 160},
#endif
	[CHAN_ENUM_5885] = {5885, INVALID_CHANNEL_NUM, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5890] = {5890, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5895] = {5895, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5900] = {5900, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5905] = {5905, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5910] = {5910, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5915] = {5915, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5920] = {5920, INVALID_CHANNEL_NUM, 2, 160},
#endif /* WLAN_FEATURE_DSRC */
#ifdef CONFIG_BAND_6GHZ
	[CHAN_ENUM_5935] = {5935, 2, 2, 20},
	[CHAN_ENUM_5955] = {5955, 1, 2, 160},
	[CHAN_ENUM_5975] = {5975, 5, 2, 160},
	[CHAN_ENUM_5995] = {5995, 9, 2, 160},
	[CHAN_ENUM_6015] = {6015, 13, 2, 160},
	[CHAN_ENUM_6035] = {6035, 17, 2, 160},
	[CHAN_ENUM_6055] = {6055, 21, 2, 160},
	[CHAN_ENUM_6075] = {6075, 25, 2, 160},
	[CHAN_ENUM_6095] = {6095, 29, 2, 160},
	[CHAN_ENUM_6115] = {6115, 33, 2, 160},
	[CHAN_ENUM_6135] = {6135, 37, 2, 160},
	[CHAN_ENUM_6155] = {6155, 41, 2, 160},
	[CHAN_ENUM_6175] = {6175, 45, 2, 160},
	[CHAN_ENUM_6195] = {6195, 49, 2, 160},
	[CHAN_ENUM_6215] = {6215, 53, 2, 160},
	[CHAN_ENUM_6235] = {6235, 57, 2, 160},
	[CHAN_ENUM_6255] = {6255, 61, 2, 160},
	[CHAN_ENUM_6275] = {6275, 65, 2, 160},
	[CHAN_ENUM_6295] = {6295, 69, 2, 160},
	[CHAN_ENUM_6315] = {6315, 73, 2, 160},
	[CHAN_ENUM_6335] = {6335, 77, 2, 160},
	[CHAN_ENUM_6355] = {6355, 81, 2, 160},
	[CHAN_ENUM_6375] = {6375, 85, 2, 160},
	[CHAN_ENUM_6395] = {6395, 89, 2, 160},
	[CHAN_ENUM_6415] = {6415, 93, 2, 160},
	[CHAN_ENUM_6435] = {6435, 97, 2, 160},
	[CHAN_ENUM_6455] = {6455, 101, 2, 160},
	[CHAN_ENUM_6475] = {6475, 105, 2, 160},
	[CHAN_ENUM_6495] = {6495, 109, 2, 160},
	[CHAN_ENUM_6515] = {6515, 113, 2, 160},
	[CHAN_ENUM_6535] = {6535, 117, 2, 160},
	[CHAN_ENUM_6555] = {6555, 121, 2, 160},
	[CHAN_ENUM_6575] = {6575, 125, 2, 160},
	[CHAN_ENUM_6595] = {6595, 129, 2, 160},
	[CHAN_ENUM_6615] = {6615, 133, 2, 160},
	[CHAN_ENUM_6635] = {6635, 137, 2, 160},
	[CHAN_ENUM_6655] = {6655, 141, 2, 160},
	[CHAN_ENUM_6675] = {6675, 145, 2, 160},
	[CHAN_ENUM_6695] = {6695, 149, 2, 160},
	[CHAN_ENUM_6715] = {6715, 153, 2, 160},
	[CHAN_ENUM_6735] = {6735, 157, 2, 160},
	[CHAN_ENUM_6755] = {6755, 161, 2, 160},
	[CHAN_ENUM_6775] = {6775, 165, 2, 160},
	[CHAN_ENUM_6795] = {6795, 169, 2, 160},
	[CHAN_ENUM_6815] = {6815, 173, 2, 160},
	[CHAN_ENUM_6835] = {6835, 177, 2, 160},
	[CHAN_ENUM_6855] = {6855, 181, 2, 160},
	[CHAN_ENUM_6875] = {6875, 185, 2, 160},
	[CHAN_ENUM_6895] = {6895, 189, 2, 160},
	[CHAN_ENUM_6915] = {6915, 193, 2, 160},
	[CHAN_ENUM_6935] = {6935, 197, 2, 160},
	[CHAN_ENUM_6955] = {6955, 201, 2, 160},
	[CHAN_ENUM_6975] = {6975, 205, 2, 160},
	[CHAN_ENUM_6995] = {6995, 209, 2, 160},
	[CHAN_ENUM_7015] = {7015, 213, 2, 160},
	[CHAN_ENUM_7035] = {7035, 217, 2, 160},
	[CHAN_ENUM_7055] = {7055, 221, 2, 160},
	[CHAN_ENUM_7075] = {7075, 225, 2, 160},
	[CHAN_ENUM_7095] = {7095, 229, 2, 160},
	[CHAN_ENUM_7115] = {7115, 233, 2, 160}
#endif /* CONFIG_BAND_6GHZ */
};

const struct chan_map channel_map_global[NUM_CHANNELS] = {
	[CHAN_ENUM_2412] = {2412, 1, 20, 40},
	[CHAN_ENUM_2417] = {2417, 2, 20, 40},
	[CHAN_ENUM_2422] = {2422, 3, 20, 40},
	[CHAN_ENUM_2427] = {2427, 4, 20, 40},
	[CHAN_ENUM_2432] = {2432, 5, 20, 40},
	[CHAN_ENUM_2437] = {2437, 6, 20, 40},
	[CHAN_ENUM_2442] = {2442, 7, 20, 40},
	[CHAN_ENUM_2447] = {2447, 8, 20, 40},
	[CHAN_ENUM_2452] = {2452, 9, 20, 40},
	[CHAN_ENUM_2457] = {2457, 10, 20, 40},
	[CHAN_ENUM_2462] = {2462, 11, 20, 40},
	[CHAN_ENUM_2467] = {2467, 12, 20, 40},
	[CHAN_ENUM_2472] = {2472, 13, 20, 40},
	[CHAN_ENUM_2484] = {2484, 14, 20, 20},

	[CHAN_ENUM_4912] = {4912, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4915] = {4915, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4917] = {4917, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4920] = {4920, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4922] = {4922, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4925] = {4925, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4927] = {4927, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4932] = {4932, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4935] = {4935, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4937] = {4937, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4940] = {4940, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4942] = {4942, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4945] = {4945, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4947] = {4947, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4950] = {4950, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4952] = {4952, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4955] = {4955, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4957] = {4957, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4960] = {4960, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4962] = {4962, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4965] = {4965, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4967] = {4967, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4970] = {4970, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4972] = {4972, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4975] = {4975, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4977] = {4977, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4980] = {4980, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4982] = {4982, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4985] = {4985, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4987] = {4987, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5032] = {5032, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5035] = {5035, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5037] = {5037, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5040] = {5040, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5042] = {5042, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5045] = {5045, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5047] = {5047, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5052] = {5052, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5055] = {5055, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5057] = {5057, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5060] = {5060, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5080] = {5080, INVALID_CHANNEL_NUM, 2, 20},

	[CHAN_ENUM_5180] = {5180, 36, 2, 160},
	[CHAN_ENUM_5200] = {5200, 40, 2, 160},
	[CHAN_ENUM_5220] = {5220, 44, 2, 160},
	[CHAN_ENUM_5240] = {5240, 48, 2, 160},
	[CHAN_ENUM_5260] = {5260, 52, 2, 160},
	[CHAN_ENUM_5280] = {5280, 56, 2, 160},
	[CHAN_ENUM_5300] = {5300, 60, 2, 160},
	[CHAN_ENUM_5320] = {5320, 64, 2, 160},
	[CHAN_ENUM_5500] = {5500, 100, 2, 160},
	[CHAN_ENUM_5520] = {5520, 104, 2, 160},
	[CHAN_ENUM_5540] = {5540, 108, 2, 160},
	[CHAN_ENUM_5560] = {5560, 112, 2, 160},
	[CHAN_ENUM_5580] = {5580, 116, 2, 160},
	[CHAN_ENUM_5600] = {5600, 120, 2, 160},
	[CHAN_ENUM_5620] = {5620, 124, 2, 160},
	[CHAN_ENUM_5640] = {5640, 128, 2, 160},
	[CHAN_ENUM_5660] = {5660, 132, 2, 160},
	[CHAN_ENUM_5680] = {5680, 136, 2, 160},
	[CHAN_ENUM_5700] = {5700, 140, 2, 160},
	[CHAN_ENUM_5720] = {5720, 144, 2, 160},
	[CHAN_ENUM_5745] = {5745, 149, 2, 160},
	[CHAN_ENUM_5765] = {5765, 153, 2, 160},
	[CHAN_ENUM_5785] = {5785, 157, 2, 160},
	[CHAN_ENUM_5805] = {5805, 161, 2, 160},
	[CHAN_ENUM_5825] = {5825, 165, 2, 160},
	[CHAN_ENUM_5845] = {5845, 169, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5850] = {5850, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5855] = {5855, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5860] = {5860, INVALID_CHANNEL_NUM, 2, 160},
#endif
	[CHAN_ENUM_5865] = {5865, 173, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5870] = {5870, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5875] = {5875, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5880] = {5880, INVALID_CHANNEL_NUM, 2, 160},
#endif
	[CHAN_ENUM_5885] = {5885, INVALID_CHANNEL_NUM, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5890] = {5890, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5895] = {5895, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5900] = {5900, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5905] = {5905, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5910] = {5910, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5915] = {5915, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5920] = {5920, INVALID_CHANNEL_NUM, 2, 160},
#endif /* WLAN_FEATURE_DSRC */
#ifdef CONFIG_BAND_6GHZ
	[CHAN_ENUM_5935] = {5935, 2, 2, 20},
	[CHAN_ENUM_5955] = {5955, 1, 2, 160},
	[CHAN_ENUM_5975] = {5975, 5, 2, 160},
	[CHAN_ENUM_5995] = {5995, 9, 2, 160},
	[CHAN_ENUM_6015] = {6015, 13, 2, 160},
	[CHAN_ENUM_6035] = {6035, 17, 2, 160},
	[CHAN_ENUM_6055] = {6055, 21, 2, 160},
	[CHAN_ENUM_6075] = {6075, 25, 2, 160},
	[CHAN_ENUM_6095] = {6095, 29, 2, 160},
	[CHAN_ENUM_6115] = {6115, 33, 2, 160},
	[CHAN_ENUM_6135] = {6135, 37, 2, 160},
	[CHAN_ENUM_6155] = {6155, 41, 2, 160},
	[CHAN_ENUM_6175] = {6175, 45, 2, 160},
	[CHAN_ENUM_6195] = {6195, 49, 2, 160},
	[CHAN_ENUM_6215] = {6215, 53, 2, 160},
	[CHAN_ENUM_6235] = {6235, 57, 2, 160},
	[CHAN_ENUM_6255] = {6255, 61, 2, 160},
	[CHAN_ENUM_6275] = {6275, 65, 2, 160},
	[CHAN_ENUM_6295] = {6295, 69, 2, 160},
	[CHAN_ENUM_6315] = {6315, 73, 2, 160},
	[CHAN_ENUM_6335] = {6335, 77, 2, 160},
	[CHAN_ENUM_6355] = {6355, 81, 2, 160},
	[CHAN_ENUM_6375] = {6375, 85, 2, 160},
	[CHAN_ENUM_6395] = {6395, 89, 2, 160},
	[CHAN_ENUM_6415] = {6415, 93, 2, 160},
	[CHAN_ENUM_6435] = {6435, 97, 2, 160},
	[CHAN_ENUM_6455] = {6455, 101, 2, 160},
	[CHAN_ENUM_6475] = {6475, 105, 2, 160},
	[CHAN_ENUM_6495] = {6495, 109, 2, 160},
	[CHAN_ENUM_6515] = {6515, 113, 2, 160},
	[CHAN_ENUM_6535] = {6535, 117, 2, 160},
	[CHAN_ENUM_6555] = {6555, 121, 2, 160},
	[CHAN_ENUM_6575] = {6575, 125, 2, 160},
	[CHAN_ENUM_6595] = {6595, 129, 2, 160},
	[CHAN_ENUM_6615] = {6615, 133, 2, 160},
	[CHAN_ENUM_6635] = {6635, 137, 2, 160},
	[CHAN_ENUM_6655] = {6655, 141, 2, 160},
	[CHAN_ENUM_6675] = {6675, 145, 2, 160},
	[CHAN_ENUM_6695] = {6695, 149, 2, 160},
	[CHAN_ENUM_6715] = {6715, 153, 2, 160},
	[CHAN_ENUM_6735] = {6735, 157, 2, 160},
	[CHAN_ENUM_6755] = {6755, 161, 2, 160},
	[CHAN_ENUM_6775] = {6775, 165, 2, 160},
	[CHAN_ENUM_6795] = {6795, 169, 2, 160},
	[CHAN_ENUM_6815] = {6815, 173, 2, 160},
	[CHAN_ENUM_6835] = {6835, 177, 2, 160},
	[CHAN_ENUM_6855] = {6855, 181, 2, 160},
	[CHAN_ENUM_6875] = {6875, 185, 2, 160},
	[CHAN_ENUM_6895] = {6895, 189, 2, 160},
	[CHAN_ENUM_6915] = {6915, 193, 2, 160},
	[CHAN_ENUM_6935] = {6935, 197, 2, 160},
	[CHAN_ENUM_6955] = {6955, 201, 2, 160},
	[CHAN_ENUM_6975] = {6975, 205, 2, 160},
	[CHAN_ENUM_6995] = {6995, 209, 2, 160},
	[CHAN_ENUM_7015] = {7015, 213, 2, 160},
	[CHAN_ENUM_7035] = {7035, 217, 2, 160},
	[CHAN_ENUM_7055] = {7055, 221, 2, 160},
	[CHAN_ENUM_7075] = {7075, 225, 2, 160},
	[CHAN_ENUM_7095] = {7095, 229, 2, 160},
	[CHAN_ENUM_7115] = {7115, 233, 2, 160}
#endif /* CONFIG_BAND_6GHZ */
};

const struct chan_map channel_map_china[NUM_CHANNELS] = {
	[CHAN_ENUM_2412] = {2412, 1, 20, 40},
	[CHAN_ENUM_2417] = {2417, 2, 20, 40},
	[CHAN_ENUM_2422] = {2422, 3, 20, 40},
	[CHAN_ENUM_2427] = {2427, 4, 20, 40},
	[CHAN_ENUM_2432] = {2432, 5, 20, 40},
	[CHAN_ENUM_2437] = {2437, 6, 20, 40},
	[CHAN_ENUM_2442] = {2442, 7, 20, 40},
	[CHAN_ENUM_2447] = {2447, 8, 20, 40},
	[CHAN_ENUM_2452] = {2452, 9, 20, 40},
	[CHAN_ENUM_2457] = {2457, 10, 20, 40},
	[CHAN_ENUM_2462] = {2462, 11, 20, 40},
	[CHAN_ENUM_2467] = {2467, 12, 20, 40},
	[CHAN_ENUM_2472] = {2472, 13, 20, 40},
	[CHAN_ENUM_2484] = {2484, 14, 20, 20},

	[CHAN_ENUM_4912] = {4912, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4915] = {4915, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4917] = {4917, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4920] = {4920, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4922] = {4922, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4925] = {4925, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4927] = {4927, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4932] = {4932, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4935] = {4935, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4937] = {4937, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4940] = {4940, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4942] = {4942, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4945] = {4945, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4947] = {4947, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4950] = {4950, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4952] = {4952, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4955] = {4955, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4957] = {4957, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4960] = {4960, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4962] = {4962, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4965] = {4965, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4967] = {4967, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4970] = {4970, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4972] = {4972, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4975] = {4975, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4977] = {4977, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4980] = {4980, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4982] = {4982, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4985] = {4985, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_4987] = {4987, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5032] = {5032, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5035] = {5035, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5037] = {5037, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5040] = {5040, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5042] = {5042, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5045] = {5045, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5047] = {5047, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5052] = {5052, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5055] = {5055, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5057] = {5057, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5060] = {5060, INVALID_CHANNEL_NUM, 2, 20},
	[CHAN_ENUM_5080] = {5080, INVALID_CHANNEL_NUM, 2, 20},

	[CHAN_ENUM_5180] = {5180, 36, 2, 160},
	[CHAN_ENUM_5200] = {5200, 40, 2, 160},
	[CHAN_ENUM_5220] = {5220, 44, 2, 160},
	[CHAN_ENUM_5240] = {5240, 48, 2, 160},
	[CHAN_ENUM_5260] = {5260, 52, 2, 160},
	[CHAN_ENUM_5280] = {5280, 56, 2, 160},
	[CHAN_ENUM_5300] = {5300, 60, 2, 160},
	[CHAN_ENUM_5320] = {5320, 64, 2, 160},
	[CHAN_ENUM_5500] = {5500, 100, 2, 160},
	[CHAN_ENUM_5520] = {5520, 104, 2, 160},
	[CHAN_ENUM_5540] = {5540, 108, 2, 160},
	[CHAN_ENUM_5560] = {5560, 112, 2, 160},
	[CHAN_ENUM_5580] = {5580, 116, 2, 160},
	[CHAN_ENUM_5600] = {5600, 120, 2, 160},
	[CHAN_ENUM_5620] = {5620, 124, 2, 160},
	[CHAN_ENUM_5640] = {5640, 128, 2, 160},
	[CHAN_ENUM_5660] = {5660, 132, 2, 160},
	[CHAN_ENUM_5680] = {5680, 136, 2, 160},
	[CHAN_ENUM_5700] = {5700, 140, 2, 160},
	[CHAN_ENUM_5720] = {5720, 144, 2, 160},
	[CHAN_ENUM_5745] = {5745, 149, 2, 160},
	[CHAN_ENUM_5765] = {5765, 153, 2, 160},
	[CHAN_ENUM_5785] = {5785, 157, 2, 160},
	[CHAN_ENUM_5805] = {5805, 161, 2, 160},
	[CHAN_ENUM_5825] = {5825, 165, 2, 160},
	[CHAN_ENUM_5845] = {5845, 169, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5850] = {5850, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5855] = {5855, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5860] = {5860, INVALID_CHANNEL_NUM, 2, 160},
#endif
	[CHAN_ENUM_5865] = {5865, INVALID_CHANNEL_NUM, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5870] = {5870, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5875] = {5875, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5880] = {5880, INVALID_CHANNEL_NUM, 2, 160},
#endif
	[CHAN_ENUM_5885] = {5885, INVALID_CHANNEL_NUM, 2, 160},
#ifdef WLAN_FEATURE_DSRC
	[CHAN_ENUM_5890] = {5890, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5895] = {5895, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5900] = {5900, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5905] = {5905, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5910] = {5910, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5915] = {5915, INVALID_CHANNEL_NUM, 2, 160},
	[CHAN_ENUM_5920] = {5920, INVALID_CHANNEL_NUM, 2, 160},
#endif /* WLAN_FEATURE_DSRC */
#ifdef CONFIG_BAND_6GHZ
	[CHAN_ENUM_5935] = {5935, 2, 2, 20},
	[CHAN_ENUM_5955] = {5955, 1, 2, 160},
	[CHAN_ENUM_5975] = {5975, 5, 2, 160},
	[CHAN_ENUM_5995] = {5995, 9, 2, 160},
	[CHAN_ENUM_6015] = {6015, 13, 2, 160},
	[CHAN_ENUM_6035] = {6035, 17, 2, 160},
	[CHAN_ENUM_6055] = {6055, 21, 2, 160},
	[CHAN_ENUM_6075] = {6075, 25, 2, 160},
	[CHAN_ENUM_6095] = {6095, 29, 2, 160},
	[CHAN_ENUM_6115] = {6115, 33, 2, 160},
	[CHAN_ENUM_6135] = {6135, 37, 2, 160},
	[CHAN_ENUM_6155] = {6155, 41, 2, 160},
	[CHAN_ENUM_6175] = {6175, 45, 2, 160},
	[CHAN_ENUM_6195] = {6195, 49, 2, 160},
	[CHAN_ENUM_6215] = {6215, 53, 2, 160},
	[CHAN_ENUM_6235] = {6235, 57, 2, 160},
	[CHAN_ENUM_6255] = {6255, 61, 2, 160},
	[CHAN_ENUM_6275] = {6275, 65, 2, 160},
	[CHAN_ENUM_6295] = {6295, 69, 2, 160},
	[CHAN_ENUM_6315] = {6315, 73, 2, 160},
	[CHAN_ENUM_6335] = {6335, 77, 2, 160},
	[CHAN_ENUM_6355] = {6355, 81, 2, 160},
	[CHAN_ENUM_6375] = {6375, 85, 2, 160},
	[CHAN_ENUM_6395] = {6395, 89, 2, 160},
	[CHAN_ENUM_6415] = {6415, 93, 2, 160},
	[CHAN_ENUM_6435] = {6435, 97, 2, 160},
	[CHAN_ENUM_6455] = {6455, 101, 2, 160},
	[CHAN_ENUM_6475] = {6475, 105, 2, 160},
	[CHAN_ENUM_6495] = {6495, 109, 2, 160},
	[CHAN_ENUM_6515] = {6515, 113, 2, 160},
	[CHAN_ENUM_6535] = {6535, 117, 2, 160},
	[CHAN_ENUM_6555] = {6555, 121, 2, 160},
	[CHAN_ENUM_6575] = {6575, 125, 2, 160},
	[CHAN_ENUM_6595] = {6595, 129, 2, 160},
	[CHAN_ENUM_6615] = {6615, 133, 2, 160},
	[CHAN_ENUM_6635] = {6635, 137, 2, 160},
	[CHAN_ENUM_6655] = {6655, 141, 2, 160},
	[CHAN_ENUM_6675] = {6675, 145, 2, 160},
	[CHAN_ENUM_6695] = {6695, 149, 2, 160},
	[CHAN_ENUM_6715] = {6715, 153, 2, 160},
	[CHAN_ENUM_6735] = {6735, 157, 2, 160},
	[CHAN_ENUM_6755] = {6755, 161, 2, 160},
	[CHAN_ENUM_6775] = {6775, 165, 2, 160},
	[CHAN_ENUM_6795] = {6795, 169, 2, 160},
	[CHAN_ENUM_6815] = {6815, 173, 2, 160},
	[CHAN_ENUM_6835] = {6835, 177, 2, 160},
	[CHAN_ENUM_6855] = {6855, 181, 2, 160},
	[CHAN_ENUM_6875] = {6875, 185, 2, 160},
	[CHAN_ENUM_6895] = {6895, 189, 2, 160},
	[CHAN_ENUM_6915] = {6915, 193, 2, 160},
	[CHAN_ENUM_6935] = {6935, 197, 2, 160},
	[CHAN_ENUM_6955] = {6955, 201, 2, 160},
	[CHAN_ENUM_6975] = {6975, 205, 2, 160},
	[CHAN_ENUM_6995] = {6995, 209, 2, 160},
	[CHAN_ENUM_7015] = {7015, 213, 2, 160},
	[CHAN_ENUM_7035] = {7035, 217, 2, 160},
	[CHAN_ENUM_7055] = {7055, 221, 2, 160},
	[CHAN_ENUM_7075] = {7075, 225, 2, 160},
	[CHAN_ENUM_7095] = {7095, 229, 2, 160},
	[CHAN_ENUM_7115] = {7115, 233, 2, 160}
#endif /* CONFIG_BAND_6GHZ */
};

void reg_init_channel_map(enum dfs_reg dfs_region)
{
	switch (dfs_region) {
	case DFS_UNINIT_REGION:
	case DFS_UNDEF_REGION:
		channel_map = channel_map_global;
		break;
	case DFS_FCC_REGION:
		channel_map = channel_map_us;
		break;
	case DFS_ETSI_REGION:
		channel_map = channel_map_eu;
		break;
	case DFS_MKK_REGION:
	case DFS_MKKN_REGION:
		channel_map = channel_map_jp;
		break;
	case DFS_CN_REGION:
		channel_map = channel_map_china;
		break;
	case DFS_KR_REGION:
		channel_map = channel_map_global;
		break;
	}
}

uint16_t reg_get_bw_value(enum phy_ch_width bw)
{
	switch (bw) {
	case CH_WIDTH_20MHZ:
		return 20;
	case CH_WIDTH_40MHZ:
		return 40;
	case CH_WIDTH_80MHZ:
		return 80;
	case CH_WIDTH_160MHZ:
		return 160;
	case CH_WIDTH_80P80MHZ:
		return 160;
	case CH_WIDTH_INVALID:
		return 0;
	case CH_WIDTH_5MHZ:
		return 5;
	case CH_WIDTH_10MHZ:
		return 10;
	case CH_WIDTH_MAX:
		return 160;
	default:
		return 0;
	}
}

struct wlan_lmac_if_reg_tx_ops *reg_get_psoc_tx_ops(
		struct wlan_objmgr_psoc *psoc)
{
	struct wlan_lmac_if_tx_ops *tx_ops;

	tx_ops = wlan_psoc_get_lmac_if_txops(psoc);
	if (!tx_ops) {
		reg_err("tx_ops is NULL");
		return NULL;
	}

	return &tx_ops->reg_ops;
}

#ifdef CONFIG_CHAN_NUM_API
enum channel_enum reg_get_chan_enum(uint8_t chan_num)
{
	uint32_t count;

	for (count = 0; count < NUM_CHANNELS; count++)
		if (channel_map[count].chan_num == chan_num)
			return count;

	reg_err_rl("invalid channel number %d", chan_num);

	return INVALID_CHANNEL;
}

enum channel_state reg_get_channel_state(struct wlan_objmgr_pdev *pdev,
					 uint8_t ch)
{
	enum channel_enum ch_idx;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	ch_idx = reg_get_chan_enum(ch);

	if (ch_idx == INVALID_CHANNEL)
		return CHANNEL_STATE_INVALID;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("pdev reg obj is NULL");
		return CHANNEL_STATE_INVALID;
	}

	return pdev_priv_obj->cur_chan_list[ch_idx].state;
}

/**
 * reg_get_5g_bonded_chan_array() - get ptr to bonded channel
 * @pdev: Pointer to pdev structure
 * @oper_ch: operating channel number
 * @bonded_chan_ar: bonded channel array
 * @array_size; Array size
 * @bonded_chan_ptr_ptr: bonded channel ptr ptr
 *
 * Return: bonded channel state
 */
static enum channel_state reg_get_5g_bonded_chan_array(
		struct wlan_objmgr_pdev *pdev,
		uint8_t oper_chan,
		const struct bonded_channel bonded_chan_ar[],
		uint16_t array_size,
		const struct bonded_channel **bonded_chan_ptr_ptr)
{
	int i;
	uint8_t chan_num;
	const struct bonded_channel *bonded_chan_ptr = NULL;
	enum channel_state chan_state = CHANNEL_STATE_INVALID;
	enum channel_state temp_chan_state;

	for (i = 0; i < array_size; i++) {
		if ((oper_chan >= bonded_chan_ar[i].start_ch) &&
		    (oper_chan <= bonded_chan_ar[i].end_ch)) {
			bonded_chan_ptr = &bonded_chan_ar[i];
			break;
		}
	}

	if (!bonded_chan_ptr)
		return chan_state;

	*bonded_chan_ptr_ptr = bonded_chan_ptr;
	chan_num =  bonded_chan_ptr->start_ch;
	while (chan_num <= bonded_chan_ptr->end_ch) {
		temp_chan_state = reg_get_channel_state(pdev, chan_num);
		if (temp_chan_state < chan_state)
			chan_state = temp_chan_state;
		chan_num = chan_num + 4;
	}

	return chan_state;
}

enum channel_state reg_get_5g_bonded_channel(
		struct wlan_objmgr_pdev *pdev, uint8_t chan_num,
		enum phy_ch_width ch_width,
		const struct bonded_channel **bonded_chan_ptr_ptr)
{
	if (ch_width == CH_WIDTH_80P80MHZ)
		return reg_get_5g_bonded_chan_array(pdev, chan_num,
				bonded_chan_80mhz_list,
				QDF_ARRAY_SIZE(bonded_chan_80mhz_list),
				bonded_chan_ptr_ptr);
	else if (ch_width == CH_WIDTH_160MHZ)
		return reg_get_5g_bonded_chan_array(pdev, chan_num,
				bonded_chan_160mhz_list,
				QDF_ARRAY_SIZE(bonded_chan_160mhz_list),
				bonded_chan_ptr_ptr);
	else if (ch_width == CH_WIDTH_80MHZ)
		return reg_get_5g_bonded_chan_array(pdev, chan_num,
				bonded_chan_80mhz_list,
				QDF_ARRAY_SIZE(bonded_chan_80mhz_list),
				bonded_chan_ptr_ptr);
	else if (ch_width == CH_WIDTH_40MHZ)
		return reg_get_5g_bonded_chan_array(pdev, chan_num,
				bonded_chan_40mhz_list,
				QDF_ARRAY_SIZE(bonded_chan_40mhz_list),
				bonded_chan_ptr_ptr);
	else
		return reg_get_channel_state(pdev, chan_num);
}

enum channel_state reg_get_5g_bonded_channel_state(
		struct wlan_objmgr_pdev *pdev,
		uint8_t ch, enum phy_ch_width bw)
{
	enum channel_enum ch_indx;
	enum channel_state chan_state;
	struct regulatory_channel *reg_channels;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	bool bw_enabled = false;
	const struct bonded_channel *bonded_chan_ptr = NULL;

	if (bw > CH_WIDTH_80P80MHZ) {
		reg_err("bw passed is not good");
		return CHANNEL_STATE_INVALID;
	}

	chan_state = reg_get_5g_bonded_channel(pdev, ch, bw, &bonded_chan_ptr);

	if ((chan_state == CHANNEL_STATE_INVALID) ||
	    (chan_state == CHANNEL_STATE_DISABLE))
		return chan_state;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("pdev reg obj is NULL");
		return CHANNEL_STATE_INVALID;
	}
	reg_channels = pdev_priv_obj->cur_chan_list;

	ch_indx = reg_get_chan_enum(ch);
	if (ch_indx == INVALID_CHANNEL)
		return CHANNEL_STATE_INVALID;
	if (bw == CH_WIDTH_5MHZ)
		bw_enabled = true;
	else if (bw == CH_WIDTH_10MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 10) &&
			(reg_channels[ch_indx].max_bw >= 10);
	else if (bw == CH_WIDTH_20MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 20) &&
			(reg_channels[ch_indx].max_bw >= 20);
	else if (bw == CH_WIDTH_40MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 40) &&
			(reg_channels[ch_indx].max_bw >= 40);
	else if (bw == CH_WIDTH_80MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 80) &&
			(reg_channels[ch_indx].max_bw >= 80);
	else if (bw == CH_WIDTH_160MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 160) &&
			(reg_channels[ch_indx].max_bw >= 160);
	else if (bw == CH_WIDTH_80P80MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 80) &&
			(reg_channels[ch_indx].max_bw >= 80);

	if (bw_enabled)
		return chan_state;
	else
		return CHANNEL_STATE_DISABLE;
}

enum channel_state reg_get_2g_bonded_channel_state(
		struct wlan_objmgr_pdev *pdev,
		uint8_t oper_ch, uint8_t sec_ch,
		enum phy_ch_width bw)
{
	enum channel_enum chan_idx;
	enum channel_state chan_state;
	struct regulatory_channel *reg_channels;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	bool bw_enabled = false;
	enum channel_state chan_state2 = CHANNEL_STATE_INVALID;

	if (bw > CH_WIDTH_40MHZ)
		return CHANNEL_STATE_INVALID;

	if (bw == CH_WIDTH_40MHZ) {
		if ((sec_ch + 4 != oper_ch) &&
		    (oper_ch + 4 != sec_ch))
			return CHANNEL_STATE_INVALID;
		chan_state2 = reg_get_channel_state(pdev, sec_ch);
		if (chan_state2 == CHANNEL_STATE_INVALID)
			return chan_state2;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return CHANNEL_STATE_INVALID;
	}

	reg_channels = pdev_priv_obj->cur_chan_list;

	chan_state = reg_get_channel_state(pdev, oper_ch);
	if (chan_state2 < chan_state)
		chan_state = chan_state2;

	if ((chan_state == CHANNEL_STATE_INVALID) ||
	    (chan_state == CHANNEL_STATE_DISABLE))
		return chan_state;

	chan_idx = reg_get_chan_enum(oper_ch);
	if (chan_idx == INVALID_CHANNEL)
		return CHANNEL_STATE_INVALID;
	if (bw == CH_WIDTH_5MHZ)
		bw_enabled = true;
	else if (bw == CH_WIDTH_10MHZ)
		bw_enabled = (reg_channels[chan_idx].min_bw <= 10) &&
			(reg_channels[chan_idx].max_bw >= 10);
	else if (bw == CH_WIDTH_20MHZ)
		bw_enabled = (reg_channels[chan_idx].min_bw <= 20) &&
			(reg_channels[chan_idx].max_bw >= 20);
	else if (bw == CH_WIDTH_40MHZ)
		bw_enabled = (reg_channels[chan_idx].min_bw <= 40) &&
			(reg_channels[chan_idx].max_bw >= 40);

	if (bw_enabled)
		return chan_state;
	else
		return CHANNEL_STATE_DISABLE;

	return CHANNEL_STATE_ENABLE;
}
#endif /* CONFIG_CHAN_NUM_API */

/**
 * reg_combine_channel_states() - Get minimum of channel state1 and state2
 * @chan_state1: Channel state1
 * @chan_state2: Channel state2
 *
 * Return: Channel state
 */
static enum channel_state reg_combine_channel_states(
	enum channel_state chan_state1,
	enum channel_state chan_state2)
{
	if ((chan_state1 == CHANNEL_STATE_INVALID) ||
	    (chan_state2 == CHANNEL_STATE_INVALID))
		return CHANNEL_STATE_INVALID;
	else
		return min(chan_state1, chan_state2);
}

#ifdef CONFIG_CHAN_NUM_API
/**
 * reg_set_5g_channel_params () - Sets channel parameteres for given bandwidth
 * @ch: channel number.
 * @ch_params: pointer to the channel parameters.
 *
 * Return: None
 */
static void reg_set_5g_channel_params(struct wlan_objmgr_pdev *pdev,
				      uint8_t ch,
				      struct ch_params *ch_params)
{
	/*
	 * Set channel parameters like center frequency for a bonded channel
	 * state. Also return the maximum bandwidth supported by the channel.
	 */

	enum channel_state chan_state = CHANNEL_STATE_ENABLE;
	enum channel_state chan_state2 = CHANNEL_STATE_ENABLE;
	const struct bonded_channel *bonded_chan_ptr = NULL;
	const struct bonded_channel *bonded_chan_ptr2 = NULL;

	if (!ch_params) {
		reg_err("ch_params is NULL");
		return;
	}

	if (ch_params->ch_width >= CH_WIDTH_MAX) {
		if (ch_params->center_freq_seg1 != 0)
			ch_params->ch_width = CH_WIDTH_80P80MHZ;
		else
			ch_params->ch_width = CH_WIDTH_160MHZ;
	}

	while (ch_params->ch_width != CH_WIDTH_INVALID) {
		bonded_chan_ptr = NULL;
		bonded_chan_ptr2 = NULL;
		chan_state = reg_get_5g_bonded_channel(
				pdev, ch, ch_params->ch_width,
				&bonded_chan_ptr);

		chan_state = reg_get_5g_bonded_channel_state(
				pdev, ch, ch_params->ch_width);

		if (ch_params->ch_width == CH_WIDTH_80P80MHZ) {
			chan_state2 = reg_get_5g_bonded_channel_state(
					pdev, ch_params->center_freq_seg1 - 2,
					CH_WIDTH_80MHZ);

			chan_state = reg_combine_channel_states(
					chan_state, chan_state2);
		}

		if ((chan_state != CHANNEL_STATE_ENABLE) &&
		    (chan_state != CHANNEL_STATE_DFS))
			goto update_bw;

		if (ch_params->ch_width <= CH_WIDTH_20MHZ) {
			ch_params->sec_ch_offset = NO_SEC_CH;
			ch_params->center_freq_seg0 = ch;
			break;
		} else if (ch_params->ch_width >= CH_WIDTH_40MHZ) {
			reg_get_5g_bonded_chan_array(
					pdev, ch, bonded_chan_40mhz_list,
					QDF_ARRAY_SIZE(bonded_chan_40mhz_list),
					&bonded_chan_ptr2);
			if (!bonded_chan_ptr || !bonded_chan_ptr2)
				goto update_bw;
			if (ch == bonded_chan_ptr2->start_ch)
				ch_params->sec_ch_offset = LOW_PRIMARY_CH;
			else
				ch_params->sec_ch_offset = HIGH_PRIMARY_CH;

			ch_params->center_freq_seg0 =
				(bonded_chan_ptr->start_ch +
				 bonded_chan_ptr->end_ch) / 2;
			break;
		}
update_bw:
		ch_params->ch_width = get_next_lower_bw[ch_params->ch_width];
	}

	if (ch_params->ch_width == CH_WIDTH_160MHZ) {
		ch_params->center_freq_seg1 = ch_params->center_freq_seg0;
		chan_state = reg_get_5g_bonded_channel(
				pdev, ch, CH_WIDTH_80MHZ, &bonded_chan_ptr);
		if (bonded_chan_ptr)
			ch_params->center_freq_seg0 =
				(bonded_chan_ptr->start_ch +
				 bonded_chan_ptr->end_ch) / 2;
	}

	/* Overwrite center_freq_seg1 to 0 for non 160 and 80+80 width */
	if (!(ch_params->ch_width == CH_WIDTH_160MHZ ||
	      ch_params->ch_width == CH_WIDTH_80P80MHZ))
		ch_params->center_freq_seg1 = 0;

	reg_nofl_debug("ch %d ch_wd %d freq0 %d freq1 %d", ch,
		       ch_params->ch_width, ch_params->center_freq_seg0,
		       ch_params->center_freq_seg1);
}

/**
 * reg_set_2g_channel_params() - set the 2.4G bonded channel parameters
 * @oper_ch: operating channel
 * @ch_params: channel parameters
 * @sec_ch_2g: 2.4G secondary channel
 *
 * Return: void
 */
static void reg_set_2g_channel_params(struct wlan_objmgr_pdev *pdev,
				      uint16_t oper_ch,
				      struct ch_params *ch_params,
				      uint16_t sec_ch_2g)
{
	enum channel_state chan_state = CHANNEL_STATE_ENABLE;

	if (ch_params->ch_width >= CH_WIDTH_MAX)
		ch_params->ch_width = CH_WIDTH_40MHZ;
	if ((reg_get_bw_value(ch_params->ch_width) > 20) && !sec_ch_2g) {
		if (oper_ch >= 1 && oper_ch <= 5)
			sec_ch_2g = oper_ch + 4;
		else if (oper_ch >= 6 && oper_ch <= 13)
			sec_ch_2g = oper_ch - 4;
	}

	while (ch_params->ch_width != CH_WIDTH_INVALID) {
		chan_state = reg_get_2g_bonded_channel_state(
				pdev, oper_ch, sec_ch_2g, ch_params->ch_width);
		if (chan_state == CHANNEL_STATE_ENABLE) {
			if (ch_params->ch_width == CH_WIDTH_40MHZ) {
				if (oper_ch < sec_ch_2g)
					ch_params->sec_ch_offset =
						LOW_PRIMARY_CH;
				else
					ch_params->sec_ch_offset =
						HIGH_PRIMARY_CH;
				ch_params->center_freq_seg0 =
					(oper_ch + sec_ch_2g) / 2;
			} else {
				ch_params->sec_ch_offset = NO_SEC_CH;
				ch_params->center_freq_seg0 = oper_ch;
			}
			break;
		}

		ch_params->ch_width = get_next_lower_bw[ch_params->ch_width];
	}
	/* Overwrite center_freq_seg1 to 0 for 2.4 Ghz */
	ch_params->center_freq_seg1 = 0;
}

void reg_set_channel_params(struct wlan_objmgr_pdev *pdev,
			    uint8_t ch, uint8_t sec_ch_2g,
			    struct ch_params *ch_params)
{
	if (REG_IS_5GHZ_CH(ch))
		reg_set_5g_channel_params(pdev, ch, ch_params);
	else if  (REG_IS_24GHZ_CH(ch))
		reg_set_2g_channel_params(pdev, ch, ch_params, sec_ch_2g);
}
#endif /* CONFIG_CHAN_NUM_API */

QDF_STATUS reg_read_default_country(struct wlan_objmgr_psoc *psoc,
				    uint8_t *country_code)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;

	if (!country_code) {
		reg_err("country_code is NULL");
		return QDF_STATUS_E_INVAL;
	}

	psoc_priv_obj = reg_get_psoc_obj(psoc);
	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_INVAL;
	}

	qdf_mem_copy(country_code, psoc_priv_obj->def_country,
		     REG_ALPHA2_LEN + 1);

	return QDF_STATUS_SUCCESS;
}

QDF_STATUS reg_get_max_5g_bw_from_country_code(uint16_t cc,
					       uint16_t *max_bw_5g)
{
	uint16_t i;
	int num_countries;

	*max_bw_5g = 0;
	reg_get_num_countries(&num_countries);

	for (i = 0; i < num_countries; i++) {
		if (g_all_countries[i].country_code == cc)
			break;
	}

	if (i == num_countries)
		return QDF_STATUS_E_FAILURE;

	*max_bw_5g = g_all_countries[i].max_bw_5g;

	return QDF_STATUS_SUCCESS;
}

QDF_STATUS reg_get_max_5g_bw_from_regdomain(uint16_t regdmn,
					    uint16_t *max_bw_5g)
{
	uint16_t i;
	int num_reg_dmn;

	*max_bw_5g = 0;
	reg_get_num_reg_dmn_pairs(&num_reg_dmn);

	for (i = 0; i < num_reg_dmn; i++) {
		if (g_reg_dmn_pairs[i].reg_dmn_pair_id == regdmn)
			break;
	}

	if (i == num_reg_dmn)
		return QDF_STATUS_E_FAILURE;

	*max_bw_5g = regdomains_5g[g_reg_dmn_pairs[i].dmn_id_5g].max_bw;

	return QDF_STATUS_SUCCESS;
}

void reg_get_current_dfs_region(struct wlan_objmgr_pdev *pdev,
				enum dfs_reg *dfs_reg)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg component pdev priv is NULL");
		return;
	}

	*dfs_reg = pdev_priv_obj->dfs_region;
}

void reg_set_dfs_region(struct wlan_objmgr_pdev *pdev,
			enum dfs_reg dfs_reg)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return;
	}

	pdev_priv_obj->dfs_region = dfs_reg;

	reg_init_channel_map(dfs_reg);
}

#ifdef CONFIG_CHAN_NUM_API
uint32_t reg_get_channel_reg_power(struct wlan_objmgr_pdev *pdev,
				   uint8_t chan_num)
{
	enum channel_enum chan_enum;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	struct regulatory_channel *reg_channels;

	chan_enum = reg_get_chan_enum(chan_num);

	if (chan_enum == INVALID_CHANNEL) {
		reg_err("channel is invalid");
		return QDF_STATUS_E_FAILURE;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	reg_channels = pdev_priv_obj->cur_chan_list;

	return reg_channels[chan_enum].tx_power;
}

qdf_freq_t reg_get_channel_freq(struct wlan_objmgr_pdev *pdev,
				uint8_t chan_num)
{
	enum channel_enum chan_enum;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	struct regulatory_channel *reg_channels;

	chan_enum = reg_get_chan_enum(chan_num);

	if (chan_enum == INVALID_CHANNEL)
		return CHANNEL_STATE_INVALID;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	reg_channels = pdev_priv_obj->cur_chan_list;

	return reg_channels[chan_enum].center_freq;
}

bool reg_is_dfs_ch(struct wlan_objmgr_pdev *pdev,
		   uint8_t chan)
{
	enum channel_state ch_state;

	ch_state = reg_get_channel_state(pdev, chan);

	return ch_state == CHANNEL_STATE_DFS;
}

bool reg_is_disable_ch(struct wlan_objmgr_pdev *pdev, uint8_t chan)
{
	enum channel_state ch_state;

	ch_state = reg_get_channel_state(pdev, chan);

	return ch_state == CHANNEL_STATE_DISABLE;
}
#endif /* CONFIG_CHAN_NUM_API */

uint8_t reg_freq_to_chan(struct wlan_objmgr_pdev *pdev,
			 qdf_freq_t freq)
{
	uint32_t count;
	struct regulatory_channel *chan_list;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	if (freq == 0) {
		reg_err_rl("Invalid freq %d", freq);
		return 0;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return 0;
	}

	chan_list = pdev_priv_obj->mas_chan_list;
	for (count = 0; count < NUM_CHANNELS; count++) {
		if (chan_list[count].center_freq >= freq)
			break;
	}

	if (count == NUM_CHANNELS)
		goto end;

	if (chan_list[count].center_freq == freq)
		return chan_list[count].chan_num;

	if (count == 0)
		goto end;

	if ((chan_list[count - 1].chan_num == INVALID_CHANNEL_NUM) ||
	    (chan_list[count].chan_num == INVALID_CHANNEL_NUM)) {
		reg_err("Frequency %d invalid in current reg domain", freq);
		return 0;
	}

	return (chan_list[count - 1].chan_num +
		(freq - chan_list[count - 1].center_freq) / 5);

end:
	reg_err_rl("invalid frequency %d", freq);
	return 0;
}

static uint16_t reg_compute_chan_to_freq(struct wlan_objmgr_pdev *pdev,
					 uint8_t chan_num,
					 enum channel_enum min_chan_range,
					 enum channel_enum max_chan_range)
{
	uint16_t count;
	struct regulatory_channel *chan_list;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return 0;
	}

	if (min_chan_range < MIN_CHANNEL || max_chan_range > MAX_CHANNEL) {
		reg_err_rl("Channel range is invalid");
		return 0;
	}

	chan_list = pdev_priv_obj->mas_chan_list;

	for (count = min_chan_range; count <= max_chan_range; count++) {
		if ((chan_list[count].state != CHANNEL_STATE_DISABLE) &&
		    !(chan_list[count].chan_flags & REGULATORY_CHAN_DISABLED)) {
			if (REG_IS_49GHZ_FREQ(chan_list[count].center_freq)) {
				if (chan_list[count].chan_num == chan_num)
					break;
				continue;
			} else if ((chan_list[count].chan_num >= chan_num) &&
				   (chan_list[count].chan_num !=
							INVALID_CHANNEL_NUM))
				break;
		}
	}

	if (count == max_chan_range + 1)
		goto end;

	if (chan_list[count].chan_num == chan_num) {
		if (chan_list[count].chan_flags & REGULATORY_CHAN_DISABLED)
			reg_err("Channel %d disabled in current reg domain",
				chan_num);
		return chan_list[count].center_freq;
	}

	if (count == min_chan_range)
		goto end;

	if ((chan_list[count - 1].chan_num == INVALID_CHANNEL_NUM) ||
	    REG_IS_49GHZ_FREQ(chan_list[count - 1].center_freq) ||
	    (chan_list[count].chan_num == INVALID_CHANNEL_NUM)) {
		reg_err("Channel %d invalid in current reg domain",
			chan_num);
		return 0;
	}

	return (chan_list[count - 1].center_freq +
		(chan_num - chan_list[count - 1].chan_num) * 5);

end:

	reg_debug_rl("Invalid channel %d", chan_num);
	return 0;
}

uint16_t reg_legacy_chan_to_freq(struct wlan_objmgr_pdev *pdev,
				 uint8_t chan_num)
{
	uint16_t min_chan_range = MIN_24GHZ_CHANNEL;
	uint16_t max_chan_range = MAX_5GHZ_CHANNEL;

	if (chan_num == 0) {
		reg_err_rl("Invalid channel %d", chan_num);
		return 0;
	}

	return reg_compute_chan_to_freq(pdev, chan_num,
					min_chan_range,
					max_chan_range);
}

qdf_freq_t reg_chan_to_freq(struct wlan_objmgr_pdev *pdev,
			    uint8_t chan_num)
{
	uint32_t count;
	struct regulatory_channel *chan_list;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	if (chan_num == 0) {
		reg_err_rl("Invalid channel %d", chan_num);
		return 0;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return 0;
	}

	chan_list = pdev_priv_obj->cur_chan_list;
	for (count = 0; count < NUM_CHANNELS; count++)
		if (chan_list[count].chan_num == chan_num) {
			if (reg_chan_in_range(chan_list,
					      pdev_priv_obj->range_2g_low,
					      pdev_priv_obj->range_2g_high,
					      pdev_priv_obj->range_5g_low,
					      pdev_priv_obj->range_5g_high,
					      count)) {
				return chan_list[count].center_freq;
			}
		}

	reg_debug_rl("invalid channel %d", chan_num);
	return 0;
}

#ifdef CONFIG_CHAN_NUM_API
bool reg_chan_is_49ghz(struct wlan_objmgr_pdev *pdev, uint8_t chan_num)
{
	qdf_freq_t freq = 0;

	freq = reg_chan_to_freq(pdev, chan_num);

	return REG_IS_49GHZ_FREQ(freq) ? true : false;
}

enum band_info reg_chan_to_band(uint8_t chan_num)
{
	if (chan_num <= 14)
		return BAND_2G;

	return BAND_5G;
}

void reg_update_nol_ch(struct wlan_objmgr_pdev *pdev,
		       uint8_t *chan_list,
		       uint8_t num_chan,
		       bool nol_chan)
{
	enum channel_enum chan_enum;
	struct regulatory_channel *mas_chan_list;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	uint16_t i;

	if (!num_chan || !chan_list) {
		reg_err("chan_list or num_ch is NULL");
		return;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!pdev_priv_obj) {
		reg_err("reg psoc private obj is NULL");
		return;
	}

	mas_chan_list = pdev_priv_obj->mas_chan_list;
	for (i = 0; i < num_chan; i++) {
		chan_enum = reg_get_chan_enum(chan_list[i]);
		if (chan_enum == INVALID_CHANNEL) {
			reg_err("Invalid ch in nol list, chan %d",
				chan_list[i]);
			continue;
		}
		mas_chan_list[chan_enum].nol_chan = nol_chan;
	}

	reg_compute_pdev_current_chan_list(pdev_priv_obj);
}
#endif /* CONFIG_CHAN_NUM_API */

QDF_STATUS reg_program_default_cc(struct wlan_objmgr_pdev *pdev,
				  uint16_t regdmn)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	struct cur_regulatory_info *reg_info;
	uint16_t cc = -1;
	uint16_t country_index = -1, regdmn_pair = -1;
	struct wlan_objmgr_psoc *psoc;
	QDF_STATUS err;

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!pdev_priv_obj) {
		reg_err("reg soc is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	reg_info = (struct cur_regulatory_info *)qdf_mem_malloc
		(sizeof(struct cur_regulatory_info));
	if (!reg_info)
		return QDF_STATUS_E_NOMEM;

	psoc = wlan_pdev_get_psoc(pdev);
	if (!psoc) {
		reg_err("psoc is NULL");
		return QDF_STATUS_E_INVAL;
	}

	reg_info->psoc = psoc;
	reg_info->phy_id = wlan_objmgr_pdev_get_pdev_id(pdev);
	reg_info->num_phy = 1;

	if (regdmn == 0) {
		reg_get_default_country(&regdmn);
		regdmn |= COUNTRY_ERD_FLAG;
	}

	if (regdmn & COUNTRY_ERD_FLAG) {
		cc = regdmn & ~COUNTRY_ERD_FLAG;

		reg_get_rdpair_from_country_code(cc,
						 &country_index,
						 &regdmn_pair);

		err = reg_get_cur_reginfo(reg_info, country_index, regdmn_pair);
		if (err == QDF_STATUS_E_FAILURE) {
			reg_err("Unable to set country code\n");
			qdf_mem_free(reg_info->reg_rules_2g_ptr);
			qdf_mem_free(reg_info->reg_rules_5g_ptr);
			qdf_mem_free(reg_info);
			return QDF_STATUS_E_FAILURE;
		}

		pdev_priv_obj->ctry_code = cc;

	} else {
		reg_get_rdpair_from_regdmn_id(regdmn, &regdmn_pair);

		err = reg_get_cur_reginfo(reg_info, country_index, regdmn_pair);
		if (err == QDF_STATUS_E_FAILURE) {
			reg_err("Unable to set country code\n");
			qdf_mem_free(reg_info->reg_rules_2g_ptr);
			qdf_mem_free(reg_info->reg_rules_5g_ptr);
			qdf_mem_free(reg_info);
			return QDF_STATUS_E_FAILURE;
		}

		pdev_priv_obj->reg_dmn_pair = regdmn;
	}

	reg_info->offload_enabled = false;
	reg_process_master_chan_list(reg_info);

	qdf_mem_free(reg_info->reg_rules_2g_ptr);
	qdf_mem_free(reg_info->reg_rules_5g_ptr);
	qdf_mem_free(reg_info);

	return QDF_STATUS_SUCCESS;
}

QDF_STATUS reg_program_chan_list(struct wlan_objmgr_pdev *pdev,
				 struct cc_regdmn_s *rd)
{
	struct cur_regulatory_info *reg_info;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	uint16_t country_index = -1, regdmn_pair = -1;
	struct wlan_objmgr_psoc *psoc;
	struct wlan_lmac_if_reg_tx_ops *tx_ops;
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;
	uint8_t pdev_id;
	uint8_t phy_id;
	QDF_STATUS err;

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!pdev_priv_obj) {
		reg_err(" pdev priv obj is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	psoc = wlan_pdev_get_psoc(pdev);
	if (!psoc) {
		reg_err("psoc is NULL");
		return QDF_STATUS_E_INVAL;
	}

	psoc_priv_obj = reg_get_psoc_obj(psoc);
	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	if (psoc_priv_obj->offload_enabled) {
		if ((rd->flags == ALPHA_IS_SET) && (rd->cc.alpha[2] == 'O'))
			pdev_priv_obj->indoor_chan_enabled = false;
		else
			pdev_priv_obj->indoor_chan_enabled = true;

		pdev_id = wlan_objmgr_pdev_get_pdev_id(pdev);
		tx_ops = reg_get_psoc_tx_ops(psoc);

		if (tx_ops->get_phy_id_from_pdev_id)
			tx_ops->get_phy_id_from_pdev_id(psoc, pdev_id, &phy_id);
		else
			phy_id = pdev_id;

		if (tx_ops->set_user_country_code) {
			psoc_priv_obj->new_init_ctry_pending[phy_id] = true;
			return tx_ops->set_user_country_code(psoc, pdev_id, rd);
		}

		return QDF_STATUS_E_FAILURE;
	}

	reg_info = (struct cur_regulatory_info *)qdf_mem_malloc
		(sizeof(struct cur_regulatory_info));
	if (!reg_info)
		return QDF_STATUS_E_NOMEM;

	reg_info->psoc = psoc;
	reg_info->phy_id = wlan_objmgr_pdev_get_pdev_id(pdev);

	if (rd->flags == CC_IS_SET) {
		reg_get_rdpair_from_country_code(rd->cc.country_code,
						 &country_index,
						 &regdmn_pair);
	} else if (rd->flags == ALPHA_IS_SET) {
		reg_get_rdpair_from_country_iso(rd->cc.alpha,
						&country_index,
						&regdmn_pair);
	} else if (rd->flags == REGDMN_IS_SET) {
		reg_get_rdpair_from_regdmn_id(rd->cc.regdmn_id,
					      &regdmn_pair);
	}

	err = reg_get_cur_reginfo(reg_info, country_index, regdmn_pair);
	if (err == QDF_STATUS_E_FAILURE) {
		reg_err("Unable to set country code\n");
		qdf_mem_free(reg_info->reg_rules_2g_ptr);
		qdf_mem_free(reg_info->reg_rules_5g_ptr);
		qdf_mem_free(reg_info);
		return QDF_STATUS_E_FAILURE;
	}

	reg_info->offload_enabled = false;
	reg_process_master_chan_list(reg_info);

	qdf_mem_free(reg_info->reg_rules_2g_ptr);
	qdf_mem_free(reg_info->reg_rules_5g_ptr);
	qdf_mem_free(reg_info);

	return QDF_STATUS_SUCCESS;
}

QDF_STATUS reg_get_current_cc(struct wlan_objmgr_pdev *pdev,
			      struct cc_regdmn_s *rd)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!pdev_priv_obj) {
		reg_err("reg pdev priv is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	if (rd->flags == CC_IS_SET) {
		rd->cc.country_code = pdev_priv_obj->ctry_code;
	} else if (rd->flags == ALPHA_IS_SET) {
		qdf_mem_copy(rd->cc.alpha, pdev_priv_obj->current_country,
			     sizeof(rd->cc.alpha));
	} else if (rd->flags == REGDMN_IS_SET) {
		rd->cc.regdmn_id = pdev_priv_obj->reg_dmn_pair;
	}

	return QDF_STATUS_SUCCESS;
}

QDF_STATUS reg_set_regdb_offloaded(struct wlan_objmgr_psoc *psoc, bool val)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;

	psoc_priv_obj = reg_get_psoc_obj(psoc);

	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	psoc_priv_obj->offload_enabled = val;

	return QDF_STATUS_SUCCESS;
}

QDF_STATUS reg_get_curr_regdomain(struct wlan_objmgr_pdev *pdev,
				  struct cur_regdmn_info *cur_regdmn)
{
	struct wlan_objmgr_psoc *psoc;
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;
	uint16_t index;
	int num_reg_dmn;
	uint8_t phy_id;
	uint8_t pdev_id;
	struct wlan_lmac_if_reg_tx_ops *tx_ops;

	psoc = wlan_pdev_get_psoc(pdev);
	psoc_priv_obj = reg_get_psoc_obj(psoc);
	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("soc reg component is NULL");
		return QDF_STATUS_E_INVAL;
	}

	pdev_id = wlan_objmgr_pdev_get_pdev_id(pdev);

	tx_ops = reg_get_psoc_tx_ops(psoc);
	if (tx_ops->get_phy_id_from_pdev_id)
		tx_ops->get_phy_id_from_pdev_id(psoc, pdev_id, &phy_id);
	else
		phy_id = pdev_id;

	cur_regdmn->regdmn_pair_id =
		psoc_priv_obj->mas_chan_params[phy_id].reg_dmn_pair;

	reg_get_num_reg_dmn_pairs(&num_reg_dmn);
	for (index = 0; index < num_reg_dmn; index++) {
		if (g_reg_dmn_pairs[index].reg_dmn_pair_id ==
				cur_regdmn->regdmn_pair_id)
			break;
	}

	if (index == num_reg_dmn) {
		reg_debug_rl("invalid regdomain");
		return QDF_STATUS_E_FAILURE;
	}

	cur_regdmn->dmn_id_2g = g_reg_dmn_pairs[index].dmn_id_2g;
	cur_regdmn->dmn_id_5g = g_reg_dmn_pairs[index].dmn_id_5g;
	cur_regdmn->ctl_2g = regdomains_2g[cur_regdmn->dmn_id_2g].ctl_val;
	cur_regdmn->ctl_5g = regdomains_5g[cur_regdmn->dmn_id_5g].ctl_val;
	cur_regdmn->dfs_region =
		regdomains_5g[cur_regdmn->dmn_id_5g].dfs_region;

	return QDF_STATUS_SUCCESS;
}

QDF_STATUS reg_modify_chan_144(struct wlan_objmgr_pdev *pdev,
			       bool enable_ch_144)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	struct wlan_objmgr_psoc *psoc;
	struct wlan_lmac_if_reg_tx_ops *reg_tx_ops;
	QDF_STATUS status;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("pdev reg component is NULL");
		return QDF_STATUS_E_INVAL;
	}

	if (pdev_priv_obj->en_chan_144 == enable_ch_144) {
		reg_info("chan 144 is already  %d", enable_ch_144);
		return QDF_STATUS_SUCCESS;
	}

	psoc = wlan_pdev_get_psoc(pdev);
	if (!psoc) {
		reg_err("psoc is NULL");
		return QDF_STATUS_E_INVAL;
	}

	psoc_priv_obj = reg_get_psoc_obj(psoc);
	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_INVAL;
	}

	reg_debug("setting chan 144: %d", enable_ch_144);
	pdev_priv_obj->en_chan_144 = enable_ch_144;

	reg_compute_pdev_current_chan_list(pdev_priv_obj);

	reg_tx_ops = reg_get_psoc_tx_ops(psoc);
	if (reg_tx_ops->fill_umac_legacy_chanlist)
		reg_tx_ops->fill_umac_legacy_chanlist(pdev,
				pdev_priv_obj->cur_chan_list);

	status = reg_send_scheduler_msg_sb(psoc, pdev);

	return status;
}

bool reg_get_en_chan_144(struct wlan_objmgr_pdev *pdev)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("pdev reg component is NULL");
		return false;
	}

	return pdev_priv_obj->en_chan_144;
}

struct wlan_psoc_host_hal_reg_capabilities_ext *reg_get_hal_reg_cap(
						struct wlan_objmgr_psoc *psoc)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;

	psoc_priv_obj = reg_get_psoc_obj(psoc);

	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return NULL;
	}

	return psoc_priv_obj->reg_cap;
}

QDF_STATUS reg_set_hal_reg_cap(
		struct wlan_objmgr_psoc *psoc,
		struct wlan_psoc_host_hal_reg_capabilities_ext *reg_cap,
		uint16_t phy_cnt)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;

	psoc_priv_obj = reg_get_psoc_obj(psoc);

	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	if (phy_cnt > PSOC_MAX_PHY_REG_CAP) {
		reg_err("phy cnt:%d is more than %d", phy_cnt,
			PSOC_MAX_PHY_REG_CAP);
		return QDF_STATUS_E_FAILURE;
	}

	qdf_mem_copy(psoc_priv_obj->reg_cap, reg_cap,
		     phy_cnt *
		     sizeof(struct wlan_psoc_host_hal_reg_capabilities_ext));

	return QDF_STATUS_SUCCESS;
}

QDF_STATUS reg_update_hal_reg_cap(struct wlan_objmgr_psoc *psoc,
				  uint32_t wireless_modes, uint8_t phy_id)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;

	if (!psoc) {
		reg_err("psoc is null");
		return QDF_STATUS_E_FAILURE;
	}

	psoc_priv_obj = reg_get_psoc_obj(psoc);

	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	psoc_priv_obj->reg_cap[phy_id].wireless_modes |= wireless_modes;

	return QDF_STATUS_SUCCESS;
}

bool reg_chan_in_range(struct regulatory_channel *chan_list,
		       qdf_freq_t low_freq_2g, qdf_freq_t high_freq_2g,
		       qdf_freq_t low_freq_5g, qdf_freq_t high_freq_5g,
		       enum channel_enum ch_enum)
{
	uint32_t low_limit_2g = NUM_CHANNELS;
	uint32_t high_limit_2g = NUM_CHANNELS;
	uint32_t low_limit_5g = NUM_CHANNELS;
	uint32_t high_limit_5g = NUM_CHANNELS;
	bool chan_in_range;
	enum channel_enum chan_enum;
	uint16_t min_bw;
	qdf_freq_t center_freq;

	for (chan_enum = 0; chan_enum < NUM_CHANNELS; chan_enum++) {
		min_bw = chan_list[chan_enum].min_bw;
		center_freq = chan_list[chan_enum].center_freq;

		if ((center_freq - min_bw / 2) >= low_freq_2g) {
			low_limit_2g = chan_enum;
			break;
		}
	}

	for (chan_enum = 0; chan_enum < NUM_CHANNELS; chan_enum++) {
		min_bw = chan_list[chan_enum].min_bw;
		center_freq = chan_list[chan_enum].center_freq;

		if ((center_freq - min_bw / 2) >= low_freq_5g) {
			low_limit_5g = chan_enum;
			break;
		}
	}

	for (chan_enum = NUM_CHANNELS - 1; chan_enum >= 0; chan_enum--) {
		min_bw = chan_list[chan_enum].min_bw;
		center_freq = chan_list[chan_enum].center_freq;

		if (center_freq + min_bw / 2 <= high_freq_2g) {
			high_limit_2g = chan_enum;
			break;
		}
		if (chan_enum == 0)
			break;
	}

	for (chan_enum = NUM_CHANNELS - 1; chan_enum >= 0; chan_enum--) {
		min_bw = chan_list[chan_enum].min_bw;
		center_freq = chan_list[chan_enum].center_freq;

		if (center_freq + min_bw / 2 <= high_freq_5g) {
			high_limit_5g = chan_enum;
			break;
		}
		if (chan_enum == 0)
			break;
	}

	chan_in_range = false;
	if  ((low_limit_2g <= ch_enum) &&
	     (high_limit_2g >= ch_enum) &&
	     (low_limit_2g != NUM_CHANNELS) &&
	     (high_limit_2g != NUM_CHANNELS))
		chan_in_range = true;
	if  ((low_limit_5g <= ch_enum) &&
	     (high_limit_5g >= ch_enum) &&
	     (low_limit_5g != NUM_CHANNELS) &&
	     (high_limit_5g != NUM_CHANNELS))
		chan_in_range = true;

	if (chan_in_range)
		return true;
	else
		return false;
}

#ifdef CONFIG_CHAN_NUM_API
void reg_update_nol_history_ch(struct wlan_objmgr_pdev *pdev,
			       uint8_t *chan_list, uint8_t num_chan,
			       bool nol_history_chan)
{
	enum channel_enum chan_enum;
	struct regulatory_channel *mas_chan_list;
	struct regulatory_channel *cur_chan_list;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	uint16_t i;

	if (!num_chan || !chan_list) {
		reg_err("chan_list or num_ch is NULL");
		return;
	}

	pdev_priv_obj = wlan_objmgr_pdev_get_comp_private_obj(
			pdev, WLAN_UMAC_COMP_REGULATORY);

	if (!pdev_priv_obj) {
		reg_err("reg psoc private obj is NULL");
		return;
	}

	mas_chan_list = pdev_priv_obj->mas_chan_list;
	cur_chan_list = pdev_priv_obj->cur_chan_list;

	for (i = 0; i < num_chan; i++) {
		chan_enum = reg_get_chan_enum(chan_list[i]);
		if (chan_enum == INVALID_CHANNEL) {
			reg_err("Invalid ch in nol list, chan %d",
				chan_list[i]);
			continue;
		}
		mas_chan_list[chan_enum].nol_history = nol_history_chan;
		cur_chan_list[chan_enum].nol_history = nol_history_chan;
	}
}

bool reg_is_24ghz_ch(uint32_t chan)
{
	return REG_IS_24GHZ_CH(chan);
}

bool reg_is_5ghz_ch(uint32_t chan)
{
	return REG_IS_5GHZ_CH(chan);
}
#endif /* CONFIG_CHAN_NUM_API */

bool reg_is_24ghz_ch_freq(uint32_t freq)
{
	return REG_IS_24GHZ_CH_FREQ(freq);
}

bool reg_is_5ghz_ch_freq(uint32_t freq)
{
	return REG_IS_5GHZ_FREQ(freq);
}

/**
 * BAND_2G_PRESENT() - Check if REG_BAND_2G is set in the band_mask
 * @band_mask: Bitmask for bands
 *
 * Return: True if REG_BAND_2G is set in the band_mask, else false
 */
static inline bool BAND_2G_PRESENT(uint8_t band_mask)
{
	return !!(band_mask & (BIT(REG_BAND_2G)));
}

/**
 * BAND_5G_PRESENT() - Check if REG_BAND_5G is set in the band_mask
 * @band_mask: Bitmask for bands
 *
 * Return: True if REG_BAND_5G is set in the band_mask, else false
 */
static inline bool BAND_5G_PRESENT(uint8_t band_mask)
{
	return !!(band_mask & (BIT(REG_BAND_5G)));
}

/**
 * reg_is_freq_in_between() - Check whether freq falls within low_freq and
 * high_freq, inclusively.
 * @low_freq - Low frequency.
 * @high_freq - High frequency.
 * @freq - Frequency to be checked.
 *
 * Return: True if freq falls within low_freq and high_freq, else false.
 */
static bool reg_is_freq_in_between(qdf_freq_t low_freq, qdf_freq_t high_freq,
				   qdf_freq_t freq)
{
	return (low_freq <= freq && freq <= high_freq);
}

static bool reg_is_ranges_overlap(qdf_freq_t low_freq, qdf_freq_t high_freq,
				  qdf_freq_t start_edge_freq,
				  qdf_freq_t end_edge_freq)
{
	return (reg_is_freq_in_between(start_edge_freq,
				       end_edge_freq,
				       low_freq) ||
		reg_is_freq_in_between(start_edge_freq,
				       end_edge_freq,
				       high_freq) ||
		reg_is_freq_in_between(low_freq,
				       high_freq,
				       start_edge_freq) ||
		reg_is_freq_in_between(low_freq,
				       high_freq,
				       end_edge_freq));
}

bool reg_is_range_overlap_2g(qdf_freq_t low_freq, qdf_freq_t high_freq)
{
	return reg_is_ranges_overlap(low_freq, high_freq,
				     TWO_GIG_STARTING_EDGE_FREQ,
				     TWO_GIG_ENDING_EDGE_FREQ);
}

bool reg_is_range_overlap_5g(qdf_freq_t low_freq, qdf_freq_t high_freq)
{
	return reg_is_ranges_overlap(low_freq, high_freq,
				     FIVE_GIG_STARTING_EDGE_FREQ,
				     FIVE_GIG_ENDING_EDGE_FREQ);
}

#ifdef CONFIG_BAND_6GHZ
bool reg_is_6ghz_chan_freq(uint16_t freq)
{
	return REG_IS_6GHZ_FREQ(freq);
}

#ifdef CONFIG_6G_FREQ_OVERLAP
bool reg_is_range_overlap_6g(qdf_freq_t low_freq, qdf_freq_t high_freq)
{
	return reg_is_ranges_overlap(low_freq, high_freq,
				     SIX_GIG_STARTING_EDGE_FREQ,
				     SIX_GIG_ENDING_EDGE_FREQ);
}

bool reg_is_range_only6g(qdf_freq_t low_freq, qdf_freq_t high_freq)
{
	if (low_freq >= high_freq) {
		reg_err_rl("Low freq is greater than or equal to high freq");
		return false;
	}

	if (reg_is_range_overlap_6g(low_freq, high_freq) &&
	    !reg_is_range_overlap_5g(low_freq, high_freq)) {
		reg_debug_rl("The device is 6G only");
		return true;
	}

	reg_debug_rl("The device is not 6G only");

	return false;
}
#endif

uint16_t reg_min_6ghz_chan_freq(void)
{
	return REG_MIN_6GHZ_CHAN_FREQ;
}

uint16_t reg_max_6ghz_chan_freq(void)
{
	return REG_MAX_6GHZ_CHAN_FREQ;
}

bool reg_is_6ghz_psc_chan_freq(uint16_t freq)
{
	if (!REG_IS_6GHZ_FREQ(freq)) {
		reg_debug(" Channel frequency is not a 6GHz frequency");
		return false;
	}

	if (!(((freq - SIX_GHZ_NON_ORPHAN_START_FREQ) + FREQ_LEFT_SHIFT) %
	      (FREQ_TO_CHAN_SCALE * NUM_80MHZ_BAND_IN_6G))) {
		return true;
	}

	reg_debug_rl("Channel freq %d MHz is not a 6GHz PSC frequency", freq);

	return false;
}

/**
 * reg_is_freq_indoor() - Check if the input frequency is an indoor frequency.
 * @pdev: Pointer to pdev.
 * @freq: Channel frequency.
 *
 * Return: Return true if the input frequency is indoor, else false.
 */
static bool reg_is_freq_indoor(struct wlan_objmgr_pdev *pdev, qdf_freq_t freq)
{
	struct regulatory_channel *cur_chan_list;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	enum channel_enum chan_enum;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return false;
	}

	chan_enum = reg_get_chan_enum_for_freq(freq);

	if (chan_enum == INVALID_CHANNEL) {
		reg_err_rl("Invalid chan enum %d", chan_enum);
		return false;
	}

	cur_chan_list = pdev_priv_obj->cur_chan_list;

	return (cur_chan_list[chan_enum].chan_flags &
		REGULATORY_CHAN_INDOOR_ONLY);
}

bool reg_is_6g_freq_indoor(struct wlan_objmgr_pdev *pdev, qdf_freq_t freq)
{
	return (REG_IS_6GHZ_FREQ(freq) && reg_is_freq_indoor(pdev, freq));
}

/**
 * reg_get_max_psd() - Get max PSD.
 * @freq: Channel frequency.
 * @bw: Channel bandwidth.
 * @reg_ap: Regulatory 6G AP type.
 * @reg_client: Regulatory 6G client type.
 * @tx_power: Pointer to tx-power.
 *
 * Return: Return QDF_STATUS_SUCCESS, if PSD is filled for 6G TPE IE
 * else return QDF_STATUS_E_FAILURE.
 */
static QDF_STATUS reg_get_max_psd(qdf_freq_t freq,
				  uint16_t bw,
				  enum reg_6g_ap_type reg_ap,
				  enum reg_6g_client_type reg_client,
				  uint8_t *tx_power)
{
	if (reg_ap == REG_INDOOR_AP) {
		switch (reg_client) {
		case REG_DEFAULT_CLIENT:
			*tx_power = REG_PSD_MAX_TXPOWER_FOR_DEFAULT_CLIENT;
			return QDF_STATUS_SUCCESS;
		case REG_SUBORDINATE_CLIENT:
			*tx_power = REG_PSD_MAX_TXPOWER_FOR_SUBORDINATE_CLIENT;
			return QDF_STATUS_SUCCESS;
		default:
			reg_err_rl("Invalid client type");
			return QDF_STATUS_E_FAILURE;
		}
	}

	return QDF_STATUS_E_FAILURE;
}

/**
 * reg_get_max_txpower_for_eirp() - Get max EIRP.
 * @pdev: Pointer to pdev.
 * @freq: Channel frequency.
 * @bw: Channel bandwidth.
 * @reg_ap: Regulatory 6G AP type.
 * @reg_client: Regulatory client type.
 * @tx_power: Pointer to tx-power.
 *
 * Return: Return QDF_STATUS_SUCCESS, if EIRP is filled for 6G TPE IE
 * else return QDF_STATUS_E_FAILURE.
 */
static QDF_STATUS reg_get_max_eirp(struct wlan_objmgr_pdev *pdev,
				   qdf_freq_t freq,
				   uint16_t bw,
				   enum reg_6g_ap_type reg_ap,
				   enum reg_6g_client_type reg_client,
				   uint8_t *tx_power)
{
	if (reg_ap == REG_INDOOR_AP) {
		switch (reg_client) {
		case REG_DEFAULT_CLIENT:
			*tx_power = reg_get_channel_reg_power_for_freq(pdev,
								       freq);
			return QDF_STATUS_SUCCESS;
		case REG_SUBORDINATE_CLIENT:
			*tx_power = REG_EIRP_MAX_TXPOWER_FOR_SUBORDINATE_CLIENT;
			return QDF_STATUS_SUCCESS;
		default:
			reg_err_rl("Invalid client type");
			return QDF_STATUS_E_FAILURE;
		}
	}

	return QDF_STATUS_E_FAILURE;
}

QDF_STATUS reg_get_max_txpower_for_6g_tpe(struct wlan_objmgr_pdev *pdev,
					  qdf_freq_t freq, uint8_t bw,
					  enum reg_6g_ap_type reg_ap,
					  enum reg_6g_client_type reg_client,
					  bool is_psd,
					  uint8_t *tx_power)
{
	if (!REG_IS_6GHZ_FREQ(freq)) {
		reg_err_rl("%d is not a 6G channel frequency", freq);
		return QDF_STATUS_E_FAILURE;
	}

	/*
	 * For now, there is support only for Indoor AP and we have only
	 * LPI power values.
	 */
	if (is_psd)
		return reg_get_max_psd(freq, bw, reg_ap, reg_client, tx_power);

	return reg_get_max_eirp(pdev, freq, bw, reg_ap, reg_client, tx_power);
}

/**
 * BAND_6G_PRESENT() - Check if REG_BAND_6G is set in the band_mask
 * @band_mask: Bitmask for bands
 *
 * Return: True if REG_BAND_6G is set in the band_mask, else false
 */
static inline bool BAND_6G_PRESENT(uint8_t band_mask)
{
	return !!(band_mask & (BIT(REG_BAND_6G)));
}
#else
static inline bool BAND_6G_PRESENT(uint8_t band_mask)
{
	return false;
}
#endif /* CONFIG_BAND_6GHZ */

uint16_t
reg_get_band_channel_list(struct wlan_objmgr_pdev *pdev,
			  uint8_t band_mask,
			  struct regulatory_channel *channel_list)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	struct regulatory_channel *cur_chan_list;
	uint16_t i, num_channels = 0;

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return 0;
	}

	cur_chan_list = pdev_priv_obj->cur_chan_list;

	if (BAND_2G_PRESENT(band_mask)) {
		for (i = MIN_24GHZ_CHANNEL; i <= MAX_24GHZ_CHANNEL; i++) {
			if ((cur_chan_list[i].state != CHANNEL_STATE_DISABLE) &&
			    !(cur_chan_list[i].chan_flags &
			      REGULATORY_CHAN_DISABLED)) {
				channel_list[num_channels] = cur_chan_list[i];
				num_channels++;
			}
		}
	}
	if (BAND_5G_PRESENT(band_mask)) {
		for (i = MIN_49GHZ_CHANNEL; i <= MAX_5GHZ_CHANNEL; i++) {
			if ((cur_chan_list[i].state != CHANNEL_STATE_DISABLE) &&
			    !(cur_chan_list[i].chan_flags &
			      REGULATORY_CHAN_DISABLED)) {
				channel_list[num_channels] = cur_chan_list[i];
				num_channels++;
			}
		}
	}
	if (BAND_6G_PRESENT(band_mask)) {
		for (i = MIN_6GHZ_CHANNEL; i <= MAX_6GHZ_CHANNEL; i++) {
			if ((cur_chan_list[i].state != CHANNEL_STATE_DISABLE) &&
			    !(cur_chan_list[i].chan_flags &
			      REGULATORY_CHAN_DISABLED)) {
				channel_list[num_channels] = cur_chan_list[i];
				num_channels++;
			}
		}
	}

	if (!num_channels) {
		reg_err("Failed to retrieve the channel list");
		return 0;
	}

	return num_channels;
}

qdf_freq_t reg_chan_band_to_freq(struct wlan_objmgr_pdev *pdev,
				 uint8_t chan_num,
				 uint8_t band_mask)
{
	enum channel_enum min_chan, max_chan;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	uint16_t freq;

	if (chan_num == 0) {
		reg_err_rl("Invalid channel %d", chan_num);
		return 0;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return 0;
	}

	if (BAND_6G_PRESENT(band_mask)) {
		if (BAND_2G_PRESENT(band_mask) ||
		    BAND_5G_PRESENT(band_mask)) {
			reg_err_rl("Incorrect band_mask %x", band_mask);
				return 0;
		}

		min_chan = MIN_6GHZ_CHANNEL;
		max_chan = MAX_6GHZ_CHANNEL;
		return reg_compute_chan_to_freq(pdev, chan_num,
						min_chan,
						max_chan);
	} else {
		if (BAND_2G_PRESENT(band_mask)) {
			min_chan = MIN_24GHZ_CHANNEL;
			max_chan = MAX_24GHZ_CHANNEL;
			freq = reg_compute_chan_to_freq(pdev, chan_num,
							min_chan,
							max_chan);
			if (freq != 0)
				return freq;
		}

		if (BAND_5G_PRESENT(band_mask)) {
			min_chan = MIN_49GHZ_CHANNEL;
			max_chan = MAX_5GHZ_CHANNEL;

			return reg_compute_chan_to_freq(pdev, chan_num,
							min_chan,
							max_chan);
		}

		reg_err_rl("Incorrect band_mask %x", band_mask);
		return 0;
	}
}

bool reg_is_49ghz_freq(qdf_freq_t freq)
{
	return REG_IS_49GHZ_FREQ(freq);
}

qdf_freq_t reg_ch_num(uint32_t ch_enum)
{
	return REG_CH_NUM(ch_enum);
}

qdf_freq_t reg_ch_to_freq(uint32_t ch_enum)
{
	return REG_CH_TO_FREQ(ch_enum);
}

#ifdef CONFIG_CHAN_NUM_API
bool reg_is_same_band_channels(uint8_t chan_num1, uint8_t chan_num2)
{
	return (chan_num1 && chan_num2 &&
		(REG_IS_5GHZ_CH(chan_num1) == REG_IS_5GHZ_CH(chan_num2)));
}

bool reg_is_channel_valid_5g_sbs(uint8_t curchan, uint8_t newchan)
{
	return REG_IS_CHANNEL_VALID_5G_SBS(curchan, newchan);
}

uint8_t reg_min_24ghz_ch_num(void)
{
	return REG_MIN_24GHZ_CH_NUM;
}

uint8_t reg_max_24ghz_ch_num(void)
{
	return REG_MAX_24GHZ_CH_NUM;
}

uint8_t reg_min_5ghz_ch_num(void)
{
	return REG_MIN_5GHZ_CH_NUM;
}

uint8_t reg_max_5ghz_ch_num(void)
{
	return REG_MAX_5GHZ_CH_NUM;
}
#endif /* CONFIG_CHAN_NUM_API */

#ifdef CONFIG_CHAN_FREQ_API
qdf_freq_t reg_min_24ghz_chan_freq(void)
{
	return REG_MIN_24GHZ_CH_FREQ;
}

qdf_freq_t reg_max_24ghz_chan_freq(void)
{
	return REG_MAX_24GHZ_CH_FREQ;
}

qdf_freq_t reg_min_5ghz_chan_freq(void)
{
	return REG_MIN_5GHZ_CH_FREQ;
}

qdf_freq_t reg_max_5ghz_chan_freq(void)
{
	return REG_MAX_5GHZ_CH_FREQ;
}
#endif /* CONFIG_CHAN_FREQ_API */

QDF_STATUS reg_enable_dfs_channels(struct wlan_objmgr_pdev *pdev,
				   bool enable)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;
	struct wlan_objmgr_psoc *psoc;
	QDF_STATUS status;
	struct wlan_lmac_if_reg_tx_ops *reg_tx_ops;

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("pdev reg component is NULL");
		return QDF_STATUS_E_INVAL;
	}

	if (pdev_priv_obj->dfs_enabled == enable) {
		reg_info("dfs_enabled is already set to %d", enable);
		return QDF_STATUS_SUCCESS;
	}

	psoc = wlan_pdev_get_psoc(pdev);
	if (!psoc) {
		reg_err("psoc is NULL");
		return QDF_STATUS_E_INVAL;
	}

	psoc_priv_obj = reg_get_psoc_obj(psoc);
	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_INVAL;
	}

	reg_info("set dfs_enabled: %d", enable);

	pdev_priv_obj->dfs_enabled = enable;

	reg_compute_pdev_current_chan_list(pdev_priv_obj);

	reg_tx_ops = reg_get_psoc_tx_ops(psoc);

	/* Fill the ic channel list with the updated current channel
	 * chan list.
	 */
	if (reg_tx_ops->fill_umac_legacy_chanlist)
		reg_tx_ops->fill_umac_legacy_chanlist(pdev,
				pdev_priv_obj->cur_chan_list);

	status = reg_send_scheduler_msg_sb(psoc, pdev);

	return status;
}

bool reg_is_regdmn_en302502_applicable(struct wlan_objmgr_pdev *pdev)
{
	struct cur_regdmn_info cur_reg_dmn;
	QDF_STATUS status;

	status = reg_get_curr_regdomain(pdev, &cur_reg_dmn);
	if (status != QDF_STATUS_SUCCESS) {
		reg_err("Failed to get reg domain");
		return false;
	}

	return reg_en302_502_regdmn(cur_reg_dmn.regdmn_pair_id);
}

QDF_STATUS reg_get_phybitmap(struct wlan_objmgr_pdev *pdev,
			     uint16_t *phybitmap)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!pdev_priv_obj) {
		reg_err("reg pdev private obj is NULL");
		return QDF_STATUS_E_FAULT;
	}

	*phybitmap = pdev_priv_obj->phybitmap;

	return QDF_STATUS_SUCCESS;
}

QDF_STATUS reg_modify_pdev_chan_range(struct wlan_objmgr_pdev *pdev)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;
	struct wlan_objmgr_psoc *psoc;
	struct wlan_lmac_if_reg_tx_ops *reg_tx_ops;
	struct wlan_psoc_host_hal_reg_capabilities_ext *reg_cap_ptr;
	uint32_t cnt;
	uint32_t phy_id;
	enum direction dir;
	QDF_STATUS status = QDF_STATUS_SUCCESS;
	struct target_pdev_info *tgt_pdev;

	tgt_pdev = wlan_pdev_get_tgt_if_handle(pdev);
	phy_id = (uint32_t)target_pdev_get_phy_idx(tgt_pdev);
	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("pdev reg component is NULL");
		return QDF_STATUS_E_INVAL;
	}

	psoc = wlan_pdev_get_psoc(pdev);
	if (!psoc) {
		reg_err("psoc is NULL");
		return QDF_STATUS_E_INVAL;
	}

	psoc_priv_obj = reg_get_psoc_obj(psoc);
	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_INVAL;
	}

	reg_cap_ptr = psoc_priv_obj->reg_cap;

	for (cnt = 0; cnt < PSOC_MAX_PHY_REG_CAP; cnt++) {
		if (!reg_cap_ptr) {
			qdf_mem_free(pdev_priv_obj);
			reg_err("reg cap ptr is NULL");
			return QDF_STATUS_E_FAULT;
		}

		if (reg_cap_ptr->phy_id == phy_id)
			break;
		reg_cap_ptr++;
	}

	if (cnt == PSOC_MAX_PHY_REG_CAP) {
		qdf_mem_free(pdev_priv_obj);
		reg_err("extended capabilities not found for pdev");
		return QDF_STATUS_E_FAULT;
	}

	if (psoc_priv_obj->offload_enabled) {
		dir = NORTHBOUND;
	} else {
		dir = SOUTHBOUND;
	}

	pdev_priv_obj->range_2g_low = reg_cap_ptr->low_2ghz_chan;
	pdev_priv_obj->range_2g_high = reg_cap_ptr->high_2ghz_chan;
	pdev_priv_obj->range_5g_low = reg_cap_ptr->low_5ghz_chan;
	pdev_priv_obj->range_5g_high = reg_cap_ptr->high_5ghz_chan;
	pdev_priv_obj->wireless_modes = reg_cap_ptr->wireless_modes;

	reg_compute_pdev_current_chan_list(pdev_priv_obj);

	reg_tx_ops = reg_get_psoc_tx_ops(psoc);

	/* Fill the ic channel list with the updated current channel
	 * chan list.
	 */
	if (reg_tx_ops->fill_umac_legacy_chanlist) {
	    reg_tx_ops->fill_umac_legacy_chanlist(pdev,
						  pdev_priv_obj->cur_chan_list);

	} else {
		if (dir == NORTHBOUND)
			status = reg_send_scheduler_msg_nb(psoc, pdev);
		else
			status = reg_send_scheduler_msg_sb(psoc, pdev);
	}

	return status;
}

QDF_STATUS reg_update_pdev_wireless_modes(struct wlan_objmgr_pdev *pdev,
					  uint32_t wireless_modes)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	pdev_priv_obj = wlan_objmgr_pdev_get_comp_private_obj(pdev,
							      WLAN_UMAC_COMP_REGULATORY);

	if (!pdev_priv_obj) {
		reg_err("reg pdev private obj is NULL");
		return QDF_STATUS_E_INVAL;
	}

	pdev_priv_obj->wireless_modes = wireless_modes;

	return QDF_STATUS_SUCCESS;
}

#ifdef DISABLE_UNII_SHARED_BANDS
/**
 * reg_is_reg_unii_band_1_or_reg_unii_band_2a() - Check the input bitmap
 * @unii_5g_bitmap: 5G UNII band bitmap
 *
 * This function checks if either REG_UNII_BAND_1 or REG_UNII_BAND_2A,
 * are present in the 5G UNII band bitmap.
 *
 * Return: Return true if REG_UNII_BAND_1 or REG_UNII_BAND_2A, are present in
 * the UNII 5g bitmap else return false.
 */
static bool
reg_is_reg_unii_band_1_or_reg_unii_band_2a(uint8_t unii_5g_bitmap)
{
	if (!unii_5g_bitmap)
		return false;

	return ((unii_5g_bitmap & (BIT(REG_UNII_BAND_1) |
		 BIT(REG_UNII_BAND_2A))) ==  unii_5g_bitmap);
}

QDF_STATUS reg_disable_chan_coex(struct wlan_objmgr_pdev *pdev,
				 uint8_t unii_5g_bitmap)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	struct wlan_lmac_if_reg_tx_ops *reg_tx_ops;
	struct wlan_objmgr_psoc *psoc;

	psoc = wlan_pdev_get_psoc(pdev);
	if (!psoc) {
		reg_err("psoc is NULL");
		return QDF_STATUS_E_INVAL;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err_rl("reg pdev priv obj is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	if (unii_5g_bitmap &&
	    !reg_is_reg_unii_band_1_or_reg_unii_band_2a(unii_5g_bitmap)) {
		reg_err_rl("Invalid unii_5g_bitmap =  %d", unii_5g_bitmap);
		return QDF_STATUS_E_FAILURE;
	}

	if (pdev_priv_obj->unii_5g_bitmap == unii_5g_bitmap) {
		reg_debug_rl("UNII bitmask for 5G channels is already set  %d",
			    unii_5g_bitmap);
		return QDF_STATUS_SUCCESS;
	}

	reg_debug_rl("Setting UNII bitmask for 5G: %d", unii_5g_bitmap);
	pdev_priv_obj->unii_5g_bitmap = unii_5g_bitmap;

	reg_compute_pdev_current_chan_list(pdev_priv_obj);

	reg_tx_ops = reg_get_psoc_tx_ops(psoc);

	if (reg_tx_ops->fill_umac_legacy_chanlist) {
		reg_tx_ops->fill_umac_legacy_chanlist(pdev,
				pdev_priv_obj->cur_chan_list);
	}

	return QDF_STATUS_SUCCESS;
}
#endif

#ifdef CONFIG_CHAN_FREQ_API
QDF_STATUS reg_get_channel_list_with_power_for_freq(struct wlan_objmgr_pdev
						    *pdev,
						    struct channel_power
						    *ch_list,
						    uint8_t *num_chan)
{
	int i, count;
	struct regulatory_channel *reg_channels;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	if (!num_chan || !ch_list) {
		reg_err("chan_list or num_ch is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	/* set the current channel list */
	reg_channels = pdev_priv_obj->cur_chan_list;

	for (i = 0, count = 0; i < NUM_CHANNELS; i++) {
		if (reg_channels[i].state &&
		    !(reg_channels[i].chan_flags & REGULATORY_CHAN_DISABLED)) {
			ch_list[count].center_freq =
				reg_channels[i].center_freq;
			ch_list[count].chan_num = reg_channels[i].chan_num;
			ch_list[count++].tx_power =
				reg_channels[i].tx_power;
		}
	}

	*num_chan = count;

	return QDF_STATUS_SUCCESS;
}

enum channel_enum reg_get_chan_enum_for_freq(qdf_freq_t freq)
{
	uint32_t count;

	for (count = 0; count < NUM_CHANNELS; count++)
		if (channel_map[count].center_freq == freq)
			return count;

	reg_err_rl("invalid channel center frequency %d", freq);

	return INVALID_CHANNEL;
}

bool
reg_is_freq_present_in_cur_chan_list(struct wlan_objmgr_pdev *pdev,
				     qdf_freq_t freq)
{
	enum channel_enum chan_enum;
	struct regulatory_channel *cur_chan_list;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err_rl("pdev reg obj is NULL");
		return false;
	}

	cur_chan_list = pdev_priv_obj->cur_chan_list;

	for (chan_enum = 0; chan_enum < NUM_CHANNELS; chan_enum++)
		if (cur_chan_list[chan_enum].center_freq == freq)
			if ((cur_chan_list[chan_enum].state !=
			     CHANNEL_STATE_DISABLE) &&
			    !(cur_chan_list[chan_enum].chan_flags &
			      REGULATORY_CHAN_DISABLED))
				return true;

	reg_debug_rl("Channel center frequency %d not found", freq);

	return false;
}

enum channel_state reg_get_channel_state_for_freq(struct wlan_objmgr_pdev *pdev,
						  qdf_freq_t freq)
{
	enum channel_enum ch_idx;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	ch_idx = reg_get_chan_enum_for_freq(freq);

	if (ch_idx == INVALID_CHANNEL)
		return CHANNEL_STATE_INVALID;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("pdev reg obj is NULL");
		return CHANNEL_STATE_INVALID;
	}

	return pdev_priv_obj->cur_chan_list[ch_idx].state;
}

static uint32_t reg_get_channel_flags_for_freq(struct wlan_objmgr_pdev *pdev,
					       qdf_freq_t freq)
{
	enum channel_enum chan_enum;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	chan_enum = reg_get_chan_enum_for_freq(freq);

	if (chan_enum == INVALID_CHANNEL) {
		reg_err("chan freq is not valid");
		return REGULATORY_CHAN_INVALID;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("pdev reg obj is NULL");
		return REGULATORY_CHAN_INVALID;
	}

	return pdev_priv_obj->cur_chan_list[chan_enum].chan_flags;
}

/**
 * reg_get_5g_bonded_chan_array_for_freq()- Return the channel state for a
 * 5G or 6G channel frequency based on the bonded channel.
 * @pdev: Pointer to pdev.
 * @freq: Channel center frequency.
 * @bonded_chan_ar: Array of bonded channel frequencies.
 * @array_size: Array size.
 * @bonded_chan_ptr_ptr: Pointer to bonded_channel_freq.
 *
 * Return: Channel State
 */
static enum channel_state
reg_get_5g_bonded_chan_array_for_freq(struct wlan_objmgr_pdev *pdev,
				      uint16_t freq,
				      const struct bonded_channel_freq
				      bonded_chan_ar[],
				      uint16_t array_size,
				      const struct bonded_channel_freq
				      **bonded_chan_ptr_ptr)
{
	int i;
	uint16_t chan_cfreq;
	const struct bonded_channel_freq *bonded_chan_ptr = NULL;
	enum channel_state chan_state = CHANNEL_STATE_INVALID;
	enum channel_state temp_chan_state;

	for (i = 0; i < array_size; i++) {
		if ((freq >= bonded_chan_ar[i].start_freq) &&
		    (freq <= bonded_chan_ar[i].end_freq)) {
			bonded_chan_ptr = &bonded_chan_ar[i];
			break;
		}
	}

	if (!bonded_chan_ptr)
		return chan_state;

	*bonded_chan_ptr_ptr = bonded_chan_ptr;
	chan_cfreq =  bonded_chan_ptr->start_freq;
	while (chan_cfreq <= bonded_chan_ptr->end_freq) {
		temp_chan_state = reg_get_channel_state_for_freq(pdev,
								 chan_cfreq);
		if (temp_chan_state < chan_state)
			chan_state = temp_chan_state;
		chan_cfreq = chan_cfreq + 20;
	}

	return chan_state;
}

/**
 * reg_get_5g_bonded_channel_for_freq()- Return the channel state for a
 * 5G or 6G channel frequency based on the channel width and bonded channel
 * @pdev: Pointer to pdev.
 * @freq: Channel center frequency.
 * @ch_width: Channel Width.
 * @bonded_chan_ptr_ptr: Pointer to bonded_channel_freq.
 *
 * Return: Channel State
 */
enum channel_state
reg_get_5g_bonded_channel_for_freq(struct wlan_objmgr_pdev *pdev,
				   uint16_t freq,
				   enum phy_ch_width ch_width,
				   const struct bonded_channel_freq
				   **bonded_chan_ptr_ptr)

{
	if (ch_width == CH_WIDTH_80P80MHZ)
		return reg_get_5g_bonded_chan_array_for_freq(pdev, freq,
				bonded_chan_80mhz_list_freq,
				QDF_ARRAY_SIZE(bonded_chan_80mhz_list_freq),
				bonded_chan_ptr_ptr);
	else if (ch_width == CH_WIDTH_160MHZ)
		return reg_get_5g_bonded_chan_array_for_freq(pdev, freq,
				bonded_chan_160mhz_list_freq,
				QDF_ARRAY_SIZE(bonded_chan_160mhz_list_freq),
				bonded_chan_ptr_ptr);
	else if (ch_width == CH_WIDTH_80MHZ)
		return reg_get_5g_bonded_chan_array_for_freq(pdev, freq,
				bonded_chan_80mhz_list_freq,
				QDF_ARRAY_SIZE(bonded_chan_80mhz_list_freq),
				bonded_chan_ptr_ptr);
	else if (ch_width == CH_WIDTH_40MHZ)
		return reg_get_5g_bonded_chan_array_for_freq(pdev, freq,
				bonded_chan_40mhz_list_freq,
				QDF_ARRAY_SIZE(bonded_chan_40mhz_list_freq),
				bonded_chan_ptr_ptr);
	else
		return reg_get_channel_state_for_freq(pdev, freq);
}

enum channel_state
reg_get_5g_bonded_channel_state_for_freq(struct wlan_objmgr_pdev *pdev,
					 qdf_freq_t freq,
					 enum phy_ch_width bw)
{
	enum channel_enum ch_indx;
	enum channel_state chan_state;
	struct regulatory_channel *reg_channels;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	bool bw_enabled = false;
	const struct bonded_channel_freq *bonded_chan_ptr = NULL;

	if (bw > CH_WIDTH_80P80MHZ) {
		reg_err_rl("bw passed is not good");
		return CHANNEL_STATE_INVALID;
	}

	chan_state = reg_get_5g_bonded_channel_for_freq(pdev, freq, bw,
							&bonded_chan_ptr);

	if ((chan_state == CHANNEL_STATE_INVALID) ||
	    (chan_state == CHANNEL_STATE_DISABLE))
		return chan_state;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("pdev reg obj is NULL");
		return CHANNEL_STATE_INVALID;
	}
	reg_channels = pdev_priv_obj->cur_chan_list;

	ch_indx = reg_get_chan_enum_for_freq(freq);
	if (ch_indx == INVALID_CHANNEL)
		return CHANNEL_STATE_INVALID;
	if (bw == CH_WIDTH_5MHZ)
		bw_enabled = true;
	else if (bw == CH_WIDTH_10MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 10) &&
			(reg_channels[ch_indx].max_bw >= 10);
	else if (bw == CH_WIDTH_20MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 20) &&
			(reg_channels[ch_indx].max_bw >= 20);
	else if (bw == CH_WIDTH_40MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 40) &&
			(reg_channels[ch_indx].max_bw >= 40);
	else if (bw == CH_WIDTH_80MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 80) &&
			(reg_channels[ch_indx].max_bw >= 80);
	else if (bw == CH_WIDTH_160MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 160) &&
			(reg_channels[ch_indx].max_bw >= 160);
	else if (bw == CH_WIDTH_80P80MHZ)
		bw_enabled = (reg_channels[ch_indx].min_bw <= 80) &&
			(reg_channels[ch_indx].max_bw >= 80);

	if (bw_enabled)
		return chan_state;
	else
		return CHANNEL_STATE_DISABLE;
}

enum channel_state
reg_get_2g_bonded_channel_state_for_freq(struct wlan_objmgr_pdev *pdev,
					 qdf_freq_t oper_ch_freq,
					 qdf_freq_t sec_ch_freq,
					 enum phy_ch_width bw)
{
	enum channel_enum chan_idx;
	enum channel_state chan_state;
	struct regulatory_channel *reg_channels;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	bool bw_enabled = false;
	enum channel_state chan_state2 = CHANNEL_STATE_INVALID;

	if (bw > CH_WIDTH_40MHZ)
		return CHANNEL_STATE_INVALID;

	if (bw == CH_WIDTH_40MHZ) {
		if ((sec_ch_freq + 20 != oper_ch_freq) &&
		    (oper_ch_freq + 20 != sec_ch_freq))
			return CHANNEL_STATE_INVALID;
		chan_state2 = reg_get_channel_state_for_freq(pdev, sec_ch_freq);
		if (chan_state2 == CHANNEL_STATE_INVALID)
			return chan_state2;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return CHANNEL_STATE_INVALID;
	}

	reg_channels = pdev_priv_obj->cur_chan_list;

	chan_state = reg_get_channel_state_for_freq(pdev, oper_ch_freq);
	if (chan_state2 < chan_state)
		chan_state = chan_state2;

	if ((chan_state == CHANNEL_STATE_INVALID) ||
	    (chan_state == CHANNEL_STATE_DISABLE))
		return chan_state;

	chan_idx = reg_get_chan_enum_for_freq(oper_ch_freq);
	if (chan_idx == INVALID_CHANNEL)
		return CHANNEL_STATE_INVALID;
	if (bw == CH_WIDTH_5MHZ)
		bw_enabled = true;
	else if (bw == CH_WIDTH_10MHZ)
		bw_enabled = (reg_channels[chan_idx].min_bw <= 10) &&
			(reg_channels[chan_idx].max_bw >= 10);
	else if (bw == CH_WIDTH_20MHZ)
		bw_enabled = (reg_channels[chan_idx].min_bw <= 20) &&
			(reg_channels[chan_idx].max_bw >= 20);
	else if (bw == CH_WIDTH_40MHZ)
		bw_enabled = (reg_channels[chan_idx].min_bw <= 40) &&
			(reg_channels[chan_idx].max_bw >= 40);

	if (bw_enabled)
		return chan_state;
	else
		return CHANNEL_STATE_DISABLE;

	return CHANNEL_STATE_ENABLE;
}

/**
 * reg_set_5g_channel_params_for_freq()- Set channel parameters like center
 * frequency for a bonded channel state. Also return the maximum bandwidth
 * supported by the channel.
 * @pdev: Pointer to pdev.
 * @freq: Channel center frequency.
 * ch_params: Pointer to ch_params.
 *
 * Return: void
 */
static void reg_set_5g_channel_params_for_freq(struct wlan_objmgr_pdev *pdev,
					       uint16_t freq,
					       struct ch_params *ch_params)
{
	/*
	 * Set channel parameters like center frequency for a bonded channel
	 * state. Also return the maximum bandwidth supported by the channel.
	 */

	enum channel_state chan_state = CHANNEL_STATE_ENABLE;
	enum channel_state chan_state2 = CHANNEL_STATE_ENABLE;
	const struct bonded_channel_freq *bonded_chan_ptr = NULL;
	const struct bonded_channel_freq *bonded_chan_ptr2 = NULL;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	enum channel_enum chan_enum;
	uint16_t max_bw;

	if (!ch_params) {
		reg_err("ch_params is NULL");
		return;
	}

	chan_enum = reg_get_chan_enum_for_freq(freq);
	if (chan_enum == INVALID_CHANNEL) {
		reg_err("chan freq is not valid");
		return;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return;
	}

	if (ch_params->ch_width >= CH_WIDTH_MAX) {
		if (ch_params->mhz_freq_seg1 != 0)
			ch_params->ch_width = CH_WIDTH_80P80MHZ;
		else
			ch_params->ch_width = CH_WIDTH_160MHZ;
	}

	max_bw = pdev_priv_obj->cur_chan_list[chan_enum].max_bw;

	while (ch_params->ch_width != CH_WIDTH_INVALID) {
		if (max_bw < reg_get_bw_value(ch_params->ch_width))
			goto update_bw;

		bonded_chan_ptr = NULL;
		bonded_chan_ptr2 = NULL;
		chan_state = reg_get_5g_bonded_channel_for_freq(
				pdev, freq, ch_params->ch_width,
				&bonded_chan_ptr);

		chan_state = reg_get_5g_bonded_channel_state_for_freq(
				pdev, freq, ch_params->ch_width);

		if (ch_params->ch_width == CH_WIDTH_80P80MHZ) {
			chan_state2 = reg_get_5g_bonded_channel_state_for_freq(
					pdev, ch_params->mhz_freq_seg1 -
					NEAREST_20MHZ_CHAN_FREQ_OFFSET,
					CH_WIDTH_80MHZ);

			chan_state = reg_combine_channel_states(
					chan_state, chan_state2);
		}

		if ((chan_state != CHANNEL_STATE_ENABLE) &&
		    (chan_state != CHANNEL_STATE_DFS))
			goto update_bw;
		if (ch_params->ch_width <= CH_WIDTH_20MHZ) {
			ch_params->sec_ch_offset = NO_SEC_CH;
			ch_params->mhz_freq_seg0 = freq;
				ch_params->center_freq_seg0 =
				reg_freq_to_chan(pdev,
						 ch_params->mhz_freq_seg0);
			break;
		} else if (ch_params->ch_width >= CH_WIDTH_40MHZ) {
			reg_get_5g_bonded_chan_array_for_freq(
			pdev, freq, bonded_chan_40mhz_list_freq,
			QDF_ARRAY_SIZE(bonded_chan_40mhz_list_freq),
			&bonded_chan_ptr2);
			if (!bonded_chan_ptr || !bonded_chan_ptr2)
				goto update_bw;
			if (freq == bonded_chan_ptr2->start_freq)
				ch_params->sec_ch_offset = LOW_PRIMARY_CH;
			else
				ch_params->sec_ch_offset = HIGH_PRIMARY_CH;

			ch_params->mhz_freq_seg0 =
				(bonded_chan_ptr->start_freq +
				 bonded_chan_ptr->end_freq) / 2;
				ch_params->center_freq_seg0 =
				reg_freq_to_chan(pdev,
						 ch_params->mhz_freq_seg0);
			break;
		}
update_bw:
		ch_params->ch_width = get_next_lower_bw[ch_params->ch_width];
	}

	if (ch_params->ch_width == CH_WIDTH_160MHZ) {
		ch_params->mhz_freq_seg1 = ch_params->mhz_freq_seg0;
			ch_params->center_freq_seg1 =
				reg_freq_to_chan(pdev,
						 ch_params->mhz_freq_seg1);

		chan_state = reg_get_5g_bonded_channel_for_freq(
				pdev, freq, CH_WIDTH_80MHZ, &bonded_chan_ptr);
		if (bonded_chan_ptr) {
			ch_params->mhz_freq_seg0 =
				(bonded_chan_ptr->start_freq +
				 bonded_chan_ptr->end_freq) / 2;
				ch_params->center_freq_seg0 =
				reg_freq_to_chan(pdev,
						 ch_params->mhz_freq_seg0);
		}
	}

	/* Overwrite mhz_freq_seg1 to 0 for non 160 and 80+80 width */
	if (!(ch_params->ch_width == CH_WIDTH_160MHZ ||
	      ch_params->ch_width == CH_WIDTH_80P80MHZ)) {
		ch_params->mhz_freq_seg1 = 0;
		ch_params->center_freq_seg1 = 0;
	}
}

/**
 * reg_set_2g_channel_params_for_freq() - set the 2.4G bonded channel parameters
 * @oper_freq: operating channel
 * @ch_params: channel parameters
 * @sec_ch_2g_freq: 2.4G secondary channel
 *
 * Return: void
 */
static void reg_set_2g_channel_params_for_freq(struct wlan_objmgr_pdev *pdev,
					       uint16_t oper_freq,
					       struct ch_params *ch_params,
					       uint16_t sec_ch_2g_freq)
{
	enum channel_state chan_state = CHANNEL_STATE_ENABLE;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	enum channel_enum chan_enum;
	uint16_t max_bw;

	chan_enum = reg_get_chan_enum_for_freq(oper_freq);
	if (chan_enum == INVALID_CHANNEL) {
		reg_err("chan freq is not valid");
		return;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return;
	}

	if (ch_params->ch_width >= CH_WIDTH_MAX)
		ch_params->ch_width = CH_WIDTH_40MHZ;
	if ((reg_get_bw_value(ch_params->ch_width) > 20) && !sec_ch_2g_freq) {
		if (oper_freq >= TWOG_CHAN_1_IN_MHZ && oper_freq <=
				TWOG_CHAN_5_IN_MHZ)
			sec_ch_2g_freq = oper_freq + 20;
		else if (oper_freq >= TWOG_CHAN_6_IN_MHZ && oper_freq <=
				TWOG_CHAN_13_IN_MHZ)
			sec_ch_2g_freq = oper_freq - 20;
	}

	max_bw = pdev_priv_obj->cur_chan_list[chan_enum].max_bw;

	while (ch_params->ch_width != CH_WIDTH_INVALID) {
		if (max_bw < reg_get_bw_value(ch_params->ch_width))
			goto update_bw;

		chan_state =
		reg_get_2g_bonded_channel_state_for_freq(pdev, oper_freq,
							 sec_ch_2g_freq,
							 ch_params->ch_width);
		if ((chan_state == CHANNEL_STATE_ENABLE) ||
		    (chan_state == CHANNEL_STATE_DFS)) {
			if (ch_params->ch_width == CH_WIDTH_40MHZ) {
				if (oper_freq < sec_ch_2g_freq)
					ch_params->sec_ch_offset =
						LOW_PRIMARY_CH;
				else
					ch_params->sec_ch_offset =
						HIGH_PRIMARY_CH;
				ch_params->mhz_freq_seg0 =
					(oper_freq + sec_ch_2g_freq) / 2;
				if (ch_params->mhz_freq_seg0 ==
						TWOG_CHAN_14_IN_MHZ)
					ch_params->center_freq_seg0 = 14;
				else
					ch_params->center_freq_seg0 =
						(ch_params->mhz_freq_seg0 -
						 TWOG_STARTING_FREQ) /
						FREQ_TO_CHAN_SCALE;
			} else {
				ch_params->sec_ch_offset = NO_SEC_CH;
				ch_params->mhz_freq_seg0 = oper_freq;
				if (ch_params->mhz_freq_seg0 ==
						TWOG_CHAN_14_IN_MHZ)
					ch_params->center_freq_seg0 = 14;
				else
					ch_params->center_freq_seg0 =
						(ch_params->mhz_freq_seg0 -
						 TWOG_STARTING_FREQ) /
						FREQ_TO_CHAN_SCALE;
			}
			break;
		}
update_bw:
		ch_params->ch_width = get_next_lower_bw[ch_params->ch_width];
	}
	/* Overwrite mhz_freq_seg1 and center_freq_seg1 to 0 for 2.4 Ghz */
	ch_params->mhz_freq_seg1 = 0;
	ch_params->center_freq_seg1 = 0;
}

void reg_set_channel_params_for_freq(struct wlan_objmgr_pdev *pdev,
				     qdf_freq_t freq,
				     qdf_freq_t sec_ch_2g_freq,
				     struct ch_params *ch_params)
{
	if (reg_is_5ghz_ch_freq(freq) || reg_is_6ghz_chan_freq(freq))
		reg_set_5g_channel_params_for_freq(pdev, freq, ch_params);
	else if  (reg_is_24ghz_ch_freq(freq))
		reg_set_2g_channel_params_for_freq(pdev, freq, ch_params,
						   sec_ch_2g_freq);
}

uint8_t reg_get_channel_reg_power_for_freq(struct wlan_objmgr_pdev *pdev,
					   qdf_freq_t freq)
{
	enum channel_enum chan_enum;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	struct regulatory_channel *reg_channels;

	chan_enum = reg_get_chan_enum_for_freq(freq);

	if (chan_enum == INVALID_CHANNEL) {
		reg_err("channel is invalid");
		return REG_INVALID_TXPOWER;
	}

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return REG_INVALID_TXPOWER;
	}

	reg_channels = pdev_priv_obj->cur_chan_list;

	return reg_channels[chan_enum].tx_power;
}

bool reg_is_dfs_for_freq(struct wlan_objmgr_pdev *pdev, qdf_freq_t freq)
{
	uint32_t chan_flags;

	chan_flags = reg_get_channel_flags_for_freq(pdev, freq);

	return chan_flags & REGULATORY_CHAN_RADAR;
}

#ifdef CONFIG_REG_CLIENT
/**
 * reg_get_psoc_mas_chan_list () - Get psoc master channel list
 * @pdev: pointer to pdev object
 * @psoc: pointer to psoc object
 *
 * Return: psoc master chanel list
 */
static struct regulatory_channel *reg_get_psoc_mas_chan_list(
						struct wlan_objmgr_pdev *pdev,
						struct wlan_objmgr_psoc *psoc)
{
	struct wlan_regulatory_psoc_priv_obj *soc_reg;
	uint8_t pdev_id;
	uint8_t phy_id;
	struct wlan_lmac_if_reg_tx_ops *reg_tx_ops;

	soc_reg = reg_get_psoc_obj(psoc);
	if (!soc_reg) {
		reg_err("reg psoc private obj is NULL");
		return NULL;
	}
	pdev_id = wlan_objmgr_pdev_get_pdev_id(pdev);

	reg_tx_ops = reg_get_psoc_tx_ops(psoc);
	if (reg_tx_ops->get_phy_id_from_pdev_id)
		reg_tx_ops->get_phy_id_from_pdev_id(psoc, pdev_id, &phy_id);
	else
		phy_id = pdev_id;

	return soc_reg->mas_chan_params[phy_id].mas_chan_list;
}
#else
static inline struct regulatory_channel *reg_get_psoc_mas_chan_list(
						struct wlan_objmgr_pdev *pdev,
						struct wlan_objmgr_psoc *psoc)
{
	return NULL;
}
#endif

void reg_update_nol_ch_for_freq(struct wlan_objmgr_pdev *pdev,
				uint16_t *chan_freq_list,
				uint8_t num_chan,
				bool nol_chan)
{
	enum channel_enum chan_enum;
	struct regulatory_channel *mas_chan_list, *psoc_mas_chan_list;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	struct wlan_objmgr_psoc *psoc;
	uint16_t i;

	if (!num_chan || !chan_freq_list) {
		reg_err("chan_freq_list or num_ch is NULL");
		return;
	}

	psoc = wlan_pdev_get_psoc(pdev);

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!pdev_priv_obj) {
		reg_err("reg pdev private obj is NULL");
		return;
	}

	psoc_mas_chan_list = reg_get_psoc_mas_chan_list(pdev, psoc);

	mas_chan_list = pdev_priv_obj->mas_chan_list;
	for (i = 0; i < num_chan; i++) {
		chan_enum = reg_get_chan_enum_for_freq(chan_freq_list[i]);
		if (chan_enum == INVALID_CHANNEL) {
			reg_err("Invalid freq in nol list, freq %d",
				chan_freq_list[i]);
			continue;
		}
		mas_chan_list[chan_enum].nol_chan = nol_chan;
		if (psoc_mas_chan_list)
			psoc_mas_chan_list[chan_enum].nol_chan = nol_chan;
	}

	reg_compute_pdev_current_chan_list(pdev_priv_obj);

	reg_send_scheduler_msg_sb(psoc, pdev);
}

void reg_update_nol_history_ch_for_freq(struct wlan_objmgr_pdev *pdev,
					uint16_t *chan_list,
					uint8_t num_chan,
					bool nol_history_chan)
{
	enum channel_enum chan_enum;
	struct regulatory_channel *mas_chan_list;
	struct regulatory_channel *cur_chan_list;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	uint16_t i;

	if (!num_chan || !chan_list) {
		reg_err("chan_list or num_ch is NULL");
		return;
	}

	pdev_priv_obj = wlan_objmgr_pdev_get_comp_private_obj(
			pdev, WLAN_UMAC_COMP_REGULATORY);

	if (!pdev_priv_obj) {
		reg_err("reg psoc private obj is NULL");
		return;
	}

	mas_chan_list = pdev_priv_obj->mas_chan_list;
	cur_chan_list = pdev_priv_obj->cur_chan_list;

	for (i = 0; i < num_chan; i++) {
		chan_enum = reg_get_chan_enum_for_freq(chan_list[i]);
		if (chan_enum == INVALID_CHANNEL) {
			reg_err("Invalid ch in nol list, chan %d",
				chan_list[i]);
			continue;
		}
		mas_chan_list[chan_enum].nol_history = nol_history_chan;
		cur_chan_list[chan_enum].nol_history = nol_history_chan;
	}
}

static inline bool REG_IS_FREQUENCY_VALID_5G_SBS(qdf_freq_t curfreq,
						 qdf_freq_t newfreq)
{
	return ((curfreq) > (newfreq) ?
	REG_CH_TO_FREQ(reg_get_chan_enum_for_freq(curfreq))
	- REG_CH_TO_FREQ(reg_get_chan_enum_for_freq(newfreq))
	> REG_SBS_SEPARATION_THRESHOLD :
	REG_CH_TO_FREQ(reg_get_chan_enum_for_freq(newfreq))
	- REG_CH_TO_FREQ(reg_get_chan_enum_for_freq(curfreq))
	> REG_SBS_SEPARATION_THRESHOLD);
}

bool reg_is_frequency_valid_5g_sbs(qdf_freq_t curfreq, qdf_freq_t newfreq)
{
	return REG_IS_FREQUENCY_VALID_5G_SBS(curfreq, newfreq);
}

qdf_freq_t reg_min_chan_freq(void)
{
	return channel_map[MIN_24GHZ_CHANNEL].center_freq;
}

qdf_freq_t reg_max_chan_freq(void)
{
	return channel_map[NUM_CHANNELS - 1].center_freq;
}

bool reg_is_same_band_freqs(qdf_freq_t freq1, qdf_freq_t freq2)
{
	return (freq1 && freq2 && ((REG_IS_6GHZ_FREQ(freq1) &&
				    REG_IS_6GHZ_FREQ(freq2)) ||
				   (REG_IS_5GHZ_FREQ(freq1) &&
				    REG_IS_5GHZ_FREQ(freq2)) ||
				   (REG_IS_24GHZ_CH_FREQ(freq1) &&
				    REG_IS_24GHZ_CH_FREQ(freq2))));
}

enum reg_wifi_band reg_freq_to_band(qdf_freq_t freq)
{
	if (REG_IS_24GHZ_CH_FREQ(freq))
		return REG_BAND_2G;
	else if (REG_IS_5GHZ_FREQ(freq) || REG_IS_49GHZ_FREQ(freq))
		return REG_BAND_5G;
	else if (REG_IS_6GHZ_FREQ(freq))
		return REG_BAND_6G;
	return REG_BAND_UNKNOWN;
}

bool reg_is_disable_for_freq(struct wlan_objmgr_pdev *pdev, qdf_freq_t freq)
{
	enum channel_state ch_state;

	ch_state = reg_get_channel_state_for_freq(pdev, freq);

	return ch_state == CHANNEL_STATE_DISABLE;
}

bool reg_is_passive_for_freq(struct wlan_objmgr_pdev *pdev, qdf_freq_t freq)
{
	uint32_t chan_flags;

	chan_flags = reg_get_channel_flags_for_freq(pdev, freq);

	return chan_flags & REGULATORY_CHAN_NO_IR;
}
#endif /* CONFIG_CHAN_FREQ_API */

uint8_t  reg_get_max_tx_power(struct wlan_objmgr_pdev *pdev)
{
	struct regulatory_channel *cur_chan_list;
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	uint8_t i, max_tx_power = 0;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev private obj is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	cur_chan_list = pdev_priv_obj->cur_chan_list;

	for (i = 0; i < NUM_CHANNELS; i++) {
		if (cur_chan_list[i].state != CHANNEL_STATE_DISABLE &&
		    cur_chan_list[i].chan_flags != REGULATORY_CHAN_DISABLED) {
			if (cur_chan_list[i].tx_power > max_tx_power)
				max_tx_power = cur_chan_list[i].tx_power;
		}
	}

	if (!max_tx_power)
		reg_err_rl("max_tx_power is zero");

	return max_tx_power;
}

QDF_STATUS reg_set_ignore_fw_reg_offload_ind(struct wlan_objmgr_psoc *psoc)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_reg;

	psoc_reg = reg_get_psoc_obj(psoc);
	if (!IS_VALID_PSOC_REG_OBJ(psoc_reg)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_INVAL;
	}

	psoc_reg->ignore_fw_reg_offload_ind = true;
	return QDF_STATUS_SUCCESS;
}

bool reg_get_ignore_fw_reg_offload_ind(struct wlan_objmgr_psoc *psoc)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_reg;

	psoc_reg = reg_get_psoc_obj(psoc);
	if (!IS_VALID_PSOC_REG_OBJ(psoc_reg))
		return false;

	return psoc_reg->ignore_fw_reg_offload_ind;
}

QDF_STATUS reg_set_6ghz_supported(struct wlan_objmgr_psoc *psoc, bool val)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;

	psoc_priv_obj = reg_get_psoc_obj(psoc);

	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	psoc_priv_obj->six_ghz_supported = val;

	return QDF_STATUS_SUCCESS;
}

QDF_STATUS
reg_set_5dot9_ghz_supported(struct wlan_objmgr_psoc *psoc, bool val)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;

	psoc_priv_obj = reg_get_psoc_obj(psoc);

	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return QDF_STATUS_E_FAILURE;
	}

	psoc_priv_obj->five_dot_nine_ghz_supported = val;

	return QDF_STATUS_SUCCESS;
}

#ifdef CONFIG_REG_CLIENT
bool reg_is_6ghz_supported(struct wlan_objmgr_psoc *psoc)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;

	psoc_priv_obj = reg_get_psoc_obj(psoc);

	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return  false;
	}

	return psoc_priv_obj->six_ghz_supported;
}
#endif

bool reg_is_5dot9_ghz_supported(struct wlan_objmgr_psoc *psoc)
{
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;

	psoc_priv_obj = reg_get_psoc_obj(psoc);

	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_err("psoc reg component is NULL");
		return  false;
	}

	return psoc_priv_obj->five_dot_nine_ghz_supported;
}

bool reg_is_fcc_regdmn(struct wlan_objmgr_pdev *pdev)
{
	struct cur_regdmn_info cur_reg_dmn;
	QDF_STATUS status;

	status = reg_get_curr_regdomain(pdev, &cur_reg_dmn);
	if (status != QDF_STATUS_SUCCESS) {
		reg_err_rl("Failed to get reg domain");
		return false;
	}

	return reg_fcc_regdmn(cur_reg_dmn.dmn_id_5g);
}

bool reg_is_5dot9_ghz_freq(struct wlan_objmgr_pdev *pdev, qdf_freq_t freq)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	pdev_priv_obj = reg_get_pdev_obj(pdev);

	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("reg pdev priv obj is NULL");
		return false;
	}

	return (freq >= channel_map_us[MIN_5DOT9_CHANNEL].center_freq &&
		freq <= channel_map_us[MAX_5DOT9_CHANNEL].center_freq);
}

bool reg_is_5dot9_ghz_chan_allowed_master_mode(struct wlan_objmgr_pdev *pdev)
{
	struct wlan_objmgr_psoc *psoc;
	struct wlan_regulatory_psoc_priv_obj *psoc_priv_obj;

	if (!pdev) {
		reg_alert("pdev is NULL");
		return true;
	}
	psoc = wlan_pdev_get_psoc(pdev);

	psoc_priv_obj = reg_get_psoc_obj(psoc);
	if (!IS_VALID_PSOC_REG_OBJ(psoc_priv_obj)) {
		reg_alert("psoc reg component is NULL");
		return true;
	}

	return psoc_priv_obj->enable_5dot9_ghz_chan_in_master_mode;
}

#ifdef DISABLE_UNII_SHARED_BANDS
QDF_STATUS
reg_get_unii_5g_bitmap(struct wlan_objmgr_pdev *pdev, uint8_t *bitmap)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err_rl("pdev reg component is NULL");
		return QDF_STATUS_E_FAILURE;
	}
	*bitmap =  pdev_priv_obj->unii_5g_bitmap;

	return QDF_STATUS_SUCCESS;
}
#endif

#ifdef CHECK_REG_PHYMODE
/**
 * reg_is_phymode_allowed() - Check if requested phymode is unallowed
 * @phy_in: phymode that the user requested
 * @phymode_bitmap: bitmap of unallowed phymodes for specific country
 *
 * Return: true if phymode is not allowed, else false
 */
static bool reg_is_phymode_unallowed(enum reg_phymode phy_in,
				     uint32_t phymode_bitmap)
{
	if (!phymode_bitmap)
		return false;

	if (phy_in == REG_PHYMODE_11AX)
		return phymode_bitmap & REGULATORY_PHYMODE_NO11AX;
	else if (phy_in == REG_PHYMODE_11AC)
		return phymode_bitmap & REGULATORY_PHYMODE_NO11AC;
	else if (phy_in == REG_PHYMODE_11N)
		return phymode_bitmap & REGULATORY_CHAN_NO11N;
	else if (phy_in == REG_PHYMODE_11G)
		return phymode_bitmap & REGULATORY_PHYMODE_NO11G;
	else if (phy_in == REG_PHYMODE_11A)
		return phymode_bitmap & REGULATORY_PHYMODE_NO11A;
	else if (phy_in == REG_PHYMODE_11B)
		return phymode_bitmap & REGULATORY_PHYMODE_NO11B;
	else
		return true;

}

enum reg_phymode reg_get_max_phymode(struct wlan_objmgr_pdev *pdev,
				     enum reg_phymode phy_in,
				     qdf_freq_t freq)
{
	struct wlan_regulatory_pdev_priv_obj *pdev_priv_obj;
	uint32_t phymode_bitmap;
	enum reg_phymode current_phymode = phy_in;

	pdev_priv_obj = reg_get_pdev_obj(pdev);
	if (!IS_VALID_PDEV_REG_OBJ(pdev_priv_obj)) {
		reg_err("pdev reg component is NULL");
		return REG_PHYMODE_INVALID;
	}

	phymode_bitmap = pdev_priv_obj->phybitmap;

	while (1) {
		if (reg_is_phymode_unallowed(current_phymode, phymode_bitmap)) {
			if (current_phymode == REG_PHYMODE_11N) {
				if (REG_IS_24GHZ_CH_FREQ(freq))
					current_phymode = REG_PHYMODE_11G;
				else
					current_phymode = REG_PHYMODE_11A;
			} else if (current_phymode == REG_PHYMODE_11A ||
				   current_phymode == REG_PHYMODE_11B) {
				reg_err("Couldn't find a suitable phymode");
				return REG_PHYMODE_INVALID;
			} else if (current_phymode > REG_PHYMODE_MAX) {
				reg_err("Unknown phymode");
				return REG_PHYMODE_INVALID;
			} else {
				current_phymode--;
			}
		} else {
			return current_phymode;
		}
	}
}
#endif /* CHECK_REG_PHYMODE */

#ifdef CONFIG_REG_CLIENT
enum band_info reg_band_bitmap_to_band_info(uint32_t band_bitmap)
{
	if ((band_bitmap & BIT(REG_BAND_2G)) &&
	    (band_bitmap & BIT(REG_BAND_5G)) &&
	    (band_bitmap & BIT(REG_BAND_6G)))
		return BAND_ALL;
	else if ((band_bitmap & BIT(REG_BAND_5G)) &&
		 (band_bitmap & BIT(REG_BAND_6G)))
		return BAND_5G;
	else if ((band_bitmap & BIT(REG_BAND_2G)) &&
		 (band_bitmap & BIT(REG_BAND_6G)))
		return BAND_2G;
	else if ((band_bitmap & BIT(REG_BAND_2G)) &&
		 (band_bitmap & BIT(REG_BAND_5G)))
		return BAND_ALL;
	else if (band_bitmap & BIT(REG_BAND_2G))
		return BAND_2G;
	else if (band_bitmap & BIT(REG_BAND_5G))
		return BAND_5G;
	else if (band_bitmap & BIT(REG_BAND_6G))
		return BAND_2G;
	else
		return BAND_UNKNOWN;
}
#endif
